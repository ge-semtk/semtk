/**
 ** Copyright 2019 General Electric Company
 **
 **
 ** Licensed under the Apache License, Version 2.0 (the "License");
 ** you may not use this file except in compliance with the License.
 ** You may obtain a copy of the License at
 ** 
 **     http://www.apache.org/licenses/LICENSE-2.0
 ** 
 ** Unless required by applicable law or agreed to in writing, software
 ** distributed under the License is distributed on an "AS IS" BASIS,
 ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ** See the License for the specific language governing permissions and
 ** limitations under the License.
 */

package com.ge.research.semtk.load.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import org.apache.commons.io.FileUtils;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Hashtable;

import com.ge.research.semtk.belmont.AutoGeneratedQueryTypes;
import com.ge.research.semtk.belmont.Node;
import com.ge.research.semtk.belmont.NodeGroup;
import com.ge.research.semtk.belmont.PropertyItem;
import com.ge.research.semtk.belmont.ValueConstraint;
import com.ge.research.semtk.belmont.runtimeConstraints.RuntimeConstraintManager;
import com.ge.research.semtk.belmont.runtimeConstraints.SupportedOperations;
import com.ge.research.semtk.edc.client.ResultsClient;
import com.ge.research.semtk.edc.client.StatusClient;
import com.ge.research.semtk.load.DataLoader;
import com.ge.research.semtk.load.dataset.CSVDataset;
import com.ge.research.semtk.load.dataset.Dataset;
import com.ge.research.semtk.load.utility.SparqlGraphJson;
import com.ge.research.semtk.ontologyTools.OntologyInfo;
import com.ge.research.semtk.resultSet.Table;
import com.ge.research.semtk.sparqlX.InMemoryInterface;
import com.ge.research.semtk.sparqlX.SparqlConnection;
import com.ge.research.semtk.sparqlX.SparqlEndpointInterface;
import com.ge.research.semtk.test.IntegrationTestUtility;
import com.ge.research.semtk.test.TestGraph;
import com.ge.research.semtk.utility.LocalLogger;

/**
 * Testing data loading WITHOUT SERVICE LAYER.
 * This is only "_IT" integration test because of the triple-store
 * @author 200001934
 *
 */
public class DataLoaderTest_IT {
	private static ArrayList<String> timingMessages = new ArrayList<String>();
	
	@BeforeClass
	public static void setup() throws Exception {
		IntegrationTestUtility.authenticateJunit();
	}
	
	@AfterClass
	public static void shutdown() throws Exception {
		Collections.sort(timingMessages);
		for (String s : timingMessages) {
			System.out.println(s);
		}
	}
	@Test
	public void testOriginal() throws Exception {
		Dataset ds = new CSVDataset("src/test/resources/testTransforms.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/testTransforms.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/testTransforms.json");

		// test
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			fail(err.toCSVString());
		}
		assertEquals(dl.getTotalRecordsProcessed(), 3);
	}	
	
	@Test
	public void testLoadFromCsv() throws Exception {

		String owlResource = "/testTransforms.owl";
		
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, owlResource);
		SparqlConnection conn = TestGraph.getSparqlConn();

		String templateFilePath = "src/test/resources/testTransforms.json";
		String csvFilePath = "src/test/resources/testTransforms.csv";
		
		boolean exceptionThrown = false;
		
		// confirm errors if not a json file
		exceptionThrown = false;
		try{
			DataLoader.loadFromCsv("file.notjson", csvFilePath, TestGraph.getUsername(), TestGraph.getPassword(), conn);
		}catch(Exception e){
			exceptionThrown = true;
			assertTrue(e.getMessage().contains("file.notjson is not a JSON file"));
		}
		assertTrue(exceptionThrown);
		
		// confirm errors if json file not found
		exceptionThrown = false;
		try{
			DataLoader.loadFromCsv("file.json", csvFilePath, TestGraph.getUsername(), TestGraph.getPassword(), conn);
		}catch(Exception e){
			exceptionThrown = true;
			assertTrue(e.getMessage().contains("Could not load JSON from file file.json"));
		}
		assertTrue(exceptionThrown);
		
		// confirm errors if not a csv file
		exceptionThrown = false;
		try{
			DataLoader.loadFromCsv(templateFilePath, "file.notcsv", TestGraph.getUsername(), TestGraph.getPassword(), conn);
		}catch(Exception e){
			exceptionThrown = true;
			assertTrue(e.getMessage().contains("file.notcsv is not a CSV file"));
		}
		assertTrue(exceptionThrown);
		
		// confirm errors if csv file not found
		exceptionThrown = false;
		try{
			DataLoader.loadFromCsv(templateFilePath, "file.csv", TestGraph.getUsername(), TestGraph.getPassword(), conn);
		}catch(Exception e){
			exceptionThrown = true;
			assertTrue(e.getMessage().contains("file.csv"));
		}
		assertTrue(exceptionThrown);
		
		// confirm works, using connection override
		int numRecordsAdded = DataLoader.loadFromCsv(templateFilePath, csvFilePath, TestGraph.getUsername(), TestGraph.getPassword(), conn);
		assertEquals(numRecordsAdded, 3);	// loaded 3 csv rows
		assertEquals(147, TestGraph.getNumTriples());  // confirmed that the graph got all the data
		
		// confirm can delete a directory containing a CSV file that has been loaded
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, owlResource);

		String tmpDirToDelete = "src/test/resources/tmpToDelete/";     			// create a directory that we can later delete
		String csvFileToDelete = tmpDirToDelete + "testTransforms.csv";
		FileUtils.copyFile(new File(csvFilePath),new File(csvFileToDelete));	// copy a CSV file here
		numRecordsAdded = DataLoader.loadFromCsv(templateFilePath, csvFileToDelete, TestGraph.getUsername(), TestGraph.getPassword(), conn);
		assertEquals(numRecordsAdded, 3);	// loaded 3 csv rows
		assertEquals(TestGraph.getNumTriples(), 147);  // confirmed that the graph got all data
		FileUtils.deleteDirectory(new File(tmpDirToDelete));  // will throw exception if fails
		
	}
	
	@Test
	public void testTransforms() throws Exception {
		// Paul
		// Test that a transform is applied properly to a column value but NOT
		// to the adjacent text

		// set up the data
		String contents = "cell,size in,lot,material,guy,treatment\n"
				+ "abcde_test,,,,,\n";
		Dataset ds = new CSVDataset(contents, true);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/testTransforms.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/testTransforms.json");

		// calculate expected uri after applying transform. Capitalize all the
		// "E"s in the column value but not the text "Cell_"
		String prefix = sgJson.getImportSpec().getUriPrefix();
		String uri = prefix + "Cell_abcdE_tEst";

		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			fail(err.toCSVString());
		}

		// look for triples
		SparqlEndpointInterface sei = TestGraph.getSei();
		Table table = sei.executeQueryToTable(TestGraph.getNodeGroupWithOInfo(sgJson).generateSparqlSelect());
		assertTrue(table.toCSVString().contains(uri));
	}
	
	@Test
	public void testBadUri() throws Exception {
		// Paul
		// Test uri with spaces and <> to make sure it is escaped properly

		// set up the data
		String contents = "Battery,Cell,birthday,color\n"
				+ "<contains space and brackets>,cellA,01/01/1966,red\n";

		//String CORRECT = "Cell_%3Ccontains%20spacE%20and%20brackEts%3E";
		Dataset ds = new CSVDataset(contents, true);

		// get json
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/sampleBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromResource(this, "sampleBattery.json");

		// calculate expected uri after applying transform. Capitalize all the
		// "E"s in the column value but not the text "Cell_"
		//String prefix = sgJson.getImportSpec().getUriPrefix();

		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());

		int records = dl.importData(true);
		assertTrue(records == 0);
		assertTrue(dl.getLoadingErrorReport().getRow(0).get(4).contains("ill-formed URI"));
	}	
	
	@Test
	public void testMessyString1() throws Exception {
		// Test string with \r and \n
		String uri = "testMessyString"; // avoid the uppercasing transform by using uppercase
		String pastelot = "This is a messy\n string \r\n line3\n";
		String contents = "cell,size in,lot,material,guy,treatment\n" + uri 	+ ",,\"" + pastelot + "\",,,\n";

		Dataset ds = new CSVDataset(contents, true);

		// get json
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/testTransforms.json");

		// calculate expected uri after applying transform. Capitalize all the "E"s in the column value but not the text "Cell_"
		String prefix = sgJson.getImportSpec().getUriPrefix();
		uri = prefix + "Cell_" + uri.replaceAll("e", "E");

		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/testTransforms.owl");

		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			fail(err.toCSVString());
		}

		// look for triples
		NodeGroup nodegroup = TestGraph.getNodeGroupWithOInfo(sgJson);
		constrainUri(nodegroup, "Cell", uri);
		returnProp(nodegroup, "Cell", "cellId");
		returnProp(nodegroup, "ScreenPrinting", "pasteLot");

		String query = nodegroup.generateSparql(AutoGeneratedQueryTypes.QUERY_DISTINCT, false, null, null, false);

		Table tab = TestGraph.runQuery(query);
		if (tab.getNumRows() < 1) {
			throw new Exception("No triples were found for uri: " + uri);
		}

		// check first pasteLot
		String answer = tab.getCell(0, "pasteLot");
		if (!answer.equals(pastelot)) {
			fail(String.format("Inserted wrong string: '%s' expecting '%s' ", answer, pastelot));
		}
	}
	
	
	@Test
	public void testMessyStringsInCsv() throws Exception {
		// Reads strings out of testStrings.csv
		//
		// Adding more test cases:
		// Fill in only the two columns already used
		// Make sure "cell" starts with "testStrings" and is unique
		// Then "lot" should be the string to be tested
		// get the csv
		Dataset ds = new CSVDataset("src/test/resources/testStrings.csv", false);
		CSVDataset csv = new CSVDataset("src/test/resources/testStrings.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/testTransforms.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/testTransforms.json");

		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			fail(err.toCSVString());
		}

		NodeGroup ng = TestGraph.getNodeGroupWithOInfo(sgJson);
		returnProp(ng, "Cell", "cellId");
		returnProp(ng, "ScreenPrinting", "pasteLot");
		constrainPropRegex(ng, "Cell", "cellId", "^testStrings");
		String query = ng.generateSparqlSelect();

		Table tab = TestGraph.runQuery(query);
		if (tab.getNumRows() < 1) {
			throw new Exception("No triples were found for uri: "); // + uri);
		}

		// put all expected results into a hashtable
		Hashtable<String, String> correct = new Hashtable<String, String>();
		ArrayList<ArrayList<String>> rows = csv.getNextRecords(1000);
		for (int i = 0; i < rows.size(); i++) {
			correct.put(rows.get(i).get(0), rows.get(i).get(2));
		}

		// loop through actual results
		for (int i = 0; i < tab.getNumRows(); i++) {
			String key = tab.getRow(i).get(1);
			String actual = tab.getRow(i).get(2);
			String expect = correct.get(key);

			// these substitutions are expected
			expect = expect.replace("\\n", "\n");
			expect = expect.replace("\\t", "\t");

			if (!actual.equals(expect)) {
				fail(String.format(
						"Bad string retrieved.  Expecting '%s' Found '%s'",	expect, actual));
			}
		}
	}
	
	@Test
	public void test_LoadData() throws Exception {
		doLoadData(false);
		doLoadData(true);
	}
	
	public void doLoadData(boolean cacheFlag) throws Exception {

		// Pre changes:   19.5s 18.5s  18.64s  17.514
		// During changes:  
		// Bigger-ish test of many import spec features and timing
		Dataset ds = new CSVDataset("src/test/resources/loadTestData.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTest.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTest.json");

		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		loadData(dl, "doLoadData", cacheFlag);

		assertEquals(dl.getTotalRecordsProcessed(), 1998);
		
		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestResults.csv");
		
	}
	
	@SuppressWarnings("deprecation")
	@Test
	public void testLoadDataSmallBatch() throws Exception {
		// Pre changes:   19.5s 18.5s  18.64s  17.514
		// During changes:  
		// Bigger-ish test of many import spec features and timing
		Dataset ds = new CSVDataset("src/test/resources/loadTestData.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTest.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTest.json");

		// import with stupid small starting batch size
		DataLoader dl = new DataLoader(sgJson, 1, ds, TestGraph.getUsername(), TestGraph.getPassword());
		
		LocalLogger.logToStdOut("Starting load");
		dl.importData(true);
		LocalLogger.logToStdOut("Finished with load");
		
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		assertEquals(dl.getTotalRecordsProcessed(), 1998);
		
		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestResults.csv");
		
	}
	
	@SuppressWarnings("deprecation")
	@Test
	public void testLoadDataLargeBatch() throws Exception {
		// Pre changes:   19.5s 18.5s  18.64s  17.514
		// During changes:  
		// Bigger-ish test of many import spec features and timing
		Dataset ds = new CSVDataset("src/test/resources/loadTestData.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTest.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTest.json");

		// import with stupid big starting batch size
		DataLoader dl = new DataLoader(sgJson, 10000, ds, TestGraph.getUsername(), TestGraph.getPassword());
		
		LocalLogger.logToStdOut("Starting load");
		dl.importData(true);
		LocalLogger.logToStdOut("Finished with load");
		
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		assertEquals(dl.getTotalRecordsProcessed(), 1998);
		
		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestResults.csv");
		
	}
	
	@Test
	public void testLoadDataMessyBaseURI() throws Exception {
		// baseURI ends with "#".  (caused a buggy ingest in the past)
		
		Dataset ds = new CSVDataset("src/test/resources/loadTestData.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTest.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestMessyBaseURI.json");
		
		// import 
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		
		LocalLogger.logToStdOut("Starting load");
		dl.importData(true);
		LocalLogger.logToStdOut("Finished with load");
		
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		assertEquals(dl.getTotalRecordsProcessed(), 1998);
		
		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestResults.csv");
		
	}
	@Test
	public void testPrecheckOnly() throws Exception {
		Dataset ds = new CSVDataset("src/test/resources/loadTestDataShort.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTest.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTest.json");

		// precheck
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true, true);  // skip ingest
		
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		// check that no records were loaded
		assertEquals(dl.getTotalRecordsProcessed(), 0); 
		
		// check that results are empty
		TestGraph.queryAndCheckResults(sgJson, this, "/testPrecheckOnlyResults.csv");
	}
	
	@Test
	public void test_LoadDataDuraBattery() throws Exception {
		doLoadDataDuraBattery(false);
		doLoadDataDuraBattery(true);
	}
	
	public void doLoadDataDuraBattery(boolean cacheFlag) throws Exception {  
		// Bigger-ish test of many import spec features and timing. 
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryData.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		
		loadData(dl, "doLoadDataDuraBattery", cacheFlag);

		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestDuraBatteryResults.csv");
		
	}
	
	@Test
	public void testLoadDataIngestTime() throws Exception {
		// tests %ingestTime
		
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBatteryIngestTime.json");

		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		
		LocalLogger.logToStdOut("Starting load");
		dl.importData(true);
		LocalLogger.logToStdOut("Finished with load");
		
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		String query = TestGraph.getNodeGroupWithOInfo(sgJson).generateSparql(AutoGeneratedQueryTypes.QUERY_DISTINCT, false, 0, null);		
		Table tab = TestGraph.runQuery(query);
		LocalDateTime sampleTime = LocalDateTime.parse(tab.getCell(1, 1));
		
		// make sure first time ingested and queried is within the last 1 minute
		LocalDateTime t2 = LocalDateTime.now().minusMinutes(1);
		assertTrue(sampleTime.compareTo(t2) > 0);
	}
	
	@Test
	public void testLoadDataDuraBatteryAsync() throws Exception {
		// Pre changes:   
		// During changes:  
		// Bigger-ish test of many import spec features and timing. 
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryData.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		
		String jobId = IntegrationTestUtility.generateJobId("testLoadDataDuraBatteryAsync");
		StatusClient sClient = IntegrationTestUtility.getStatusClient(jobId);
		ResultsClient rClient = IntegrationTestUtility.getResultsClient();
		try {
			dl.runAsync(true, false, sClient, rClient);
			
			int percent = 1;
			int lastPercent = 0;
			while (percent < 100 && percent > lastPercent) {
				lastPercent = percent;
				percent = sClient.execWaitForPercentOrMsec(100, 60000);
			}
			
			assertTrue("ingest bogged down for 60 seconds. Percent complete stuck at: " + String.valueOf(percent), percent == 100);
			assertTrue("ingest failed: " + sClient.execGetStatusMessage(), sClient.execIsSuccess());
		} finally {
			sClient.execDeleteJob();
		}

		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestDuraBatteryResults.csv");
		
	}
	
	@Test
	public void testLoadDataDuraBatteryEmptyCol() throws Exception {
		// Catch the error when a URI mappingItem column contains empty
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryData.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDBattEmptyCol.json");

		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		
		LocalLogger.logToStdOut("Starting load");
		dl.importData(true);
		LocalLogger.logToStdOut("Finished with load");
		
		Table err = dl.getLoadingErrorReport();
		assertEquals(1, err.getNumRows());
		assertTrue(err.toCSVString().contains("Empty values in"));
		assertTrue(err.toCSVString().contains("only colors"));
	}
	
	@Test
	public void testLoadDataDuraBatteryEmptyColAsync() throws Exception {
		// Catch the error when a URI mappingItem column contains empty
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryData.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDBattEmptyCol.json");

		String jobId = IntegrationTestUtility.generateJobId("testLoadDataDuraBatteryEmptyColAsync");
		StatusClient sClient = IntegrationTestUtility.getStatusClient(jobId);
		ResultsClient rClient = IntegrationTestUtility.getResultsClient();
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());

		try {
			dl.runAsync(true, false, sClient, rClient);

			int percent = 1;
			int lastPercent = 0;
			while (percent < 100 && percent > lastPercent) {
				lastPercent = percent;
				percent = sClient.execWaitForPercentOrMsec(100, 60000);
			}
			
			assertTrue("ingest bogged down for 60 seconds. Percent complete stuck at: " + String.valueOf(percent), percent == 100);
			assertTrue("ingest succeeded unexpectedly", !sClient.execIsSuccess());
			
			Table err = rClient.getTableResultsJson(jobId, 10000);
			assertEquals(1, err.getNumRows());
			assertTrue(err.toCSVString().contains("Empty values in"));
			assertTrue(err.toCSVString().contains("only colors"));
		} finally {
			sClient.execDeleteJob();
		}

		
	}
	
	@Test
	public void test_TypedString() throws Exception {
		
		doTypedString(true);   // FAILS with un-typed literals in jena dump
		doTypedString(false);
	}
	
	/**
	 * Insert a few lines
	 * Try to retrieve a typed literal string "onlycolor"^^XMLSchema:string
	 * (Make sure type isn't lost during cache process)
	 */
	public void doTypedString(boolean cacheFlag) throws Exception {
		// setup
		TestGraph.clearGraph();
				
		// ==== pre set some data =====
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson0 = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");
		Dataset ds0 = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);
		DataLoader dl0 = new DataLoader(sgJson0, ds0, TestGraph.getUsername(), TestGraph.getPassword());
		loadData(dl0, "doLookupBatteryIdAddDesc PRELOAD", cacheFlag);
		
		Table err0 = dl0.getLoadingErrorReport();
		if (err0.getNumRows() > 0) {
			fail(err0.toCSVString());
		}

		// run raw SPARQL to retrieve typed string in a FILTER clause
		Table t2 = TestGraph.runQuery(
				"prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#> " +
						"SELECT * FROM <"+ TestGraph.getSei().getGraph() + "> " + 
						"WHERE { ?s ?p ?o .  FILTER ( str(?o) = \"onlycolor\") }"
				);
		assertEquals("FILTER clause did not retrieve literal string when cacheFlag=" + (cacheFlag?"true":"false"), 1, t2.getNumRows());

				
		// run raw SPARQL to retrieve typed string in a VALUES clause
		Table t = TestGraph.runQuery(
				"prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#> " +
				"SELECT * FROM <"+ TestGraph.getSei().getGraph() + "> " + 
				"WHERE { ?s ?p ?o .  VALUES ?o {\"onlycolor\"^^XMLSchema:string } }"
				); 
		
		// now we know/accept that cache insert will indeed strip the type off strings
		System.out.println(
				"VALUES clause " + (t.getNumRows() == 0 ? "DID NOT ":"DID ") + 
				" retrieve literal string with FROM when cacheFlag=" + (cacheFlag?"true":"false") );
		
	}
	
	@Test
	public void test_LookupBatteryIdAddDesc() throws Exception {
		doLookupBatteryIdAddDesc(true);  
		doLookupBatteryIdAddDesc(false);
	}
	
	public void doLookupBatteryIdAddDesc(boolean cacheFlag) throws Exception {

		// setup
		TestGraph.clearGraph();
				
		// ==== pre set some data =====
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson0 = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");
		Dataset ds0 = new CSVDataset("src/test/resources/loadTestDuraBatteryData.csv", false);

		DataLoader dl0 = new DataLoader(sgJson0, ds0, TestGraph.getUsername(), TestGraph.getPassword());
		
		
		loadData(dl0, "doLookupBatteryIdAddDesc PRELOAD", cacheFlag);

		// It looks like when we insert via inMemory graph, the strings go in as plain literals.
		// InMemoryInterfaceTest_IT.testInsertSelectTypedString() shows they go into the in-memory graph ok.
		// test_TypedString() shows that cached load is failing to preserve type
		//
		// So the problem must be in dumping to OWL/RDF and uploading.   The Owl looks wrong.  
		//        <j.0:batteryId>id_733344685</j.0:batteryId>
		//    instead of
		//        <j.0:batteryId>"id_733344685"^^XMLSchema:string</j.0:batteryId>
		// When we do URI lookups, we query for "value"^^xsd:string
		//
		//   http://iswc2011.semanticweb.org/fileadmin/iswc/Papers/Workshops/SSWS/Emmons-et-all-SSWS2011.pdf
		//   	literal types are often handled inconsistently
		// 	    filter clause will probably work
		//
		// BEST: figure out how to dump to turtle since owl/rdf is too verbose AND wrong
		
				
				
		// Try URI lookup
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/lookupBatteryIdAddDesc.json");

		Dataset ds = new CSVDataset("src/test/resources/lookupBatteryIdAddDescData.csv", false);
		
		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		loadData(dl, "doLookupBatteryIdAddDesc LOOKUP", cacheFlag);
		
		TestGraph.queryAndCheckResults(sgJson, this, "/lookupBatteryIdAddDescResults.csv");
		
	}
	
	@Test
	public void test_LookupBatteryIdAddDescShort() throws Exception {
		doLookupBatteryIdAddDescShort(false);
		doLookupBatteryIdAddDescShort(true);
	}

	public void doLookupBatteryIdAddDescShort(boolean cacheFlag) throws Exception {
		// setup
		TestGraph.clearGraph();
				
		// ==== pre set some data =====
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson0 = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");
		Dataset ds0 = new CSVDataset("src/test/resources/loadTestDuraBatteryShortData.csv", false);

		DataLoader dl0 = new DataLoader(sgJson0, ds0, TestGraph.getUsername(), TestGraph.getPassword());
		loadData(dl0, "testLookupBatteryIdAddDescShort preload", cacheFlag);
				
		LocalLogger.logToStdErr("------ done import 1 -------");		
		// Try URI lookup
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/lookupBatteryIdAddDesc.json");

		Dataset ds = new CSVDataset("src/test/resources/lookupBatteryIdAddDescShortData.csv", false);
		
		// import the actual test: lookup URI and add description
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		loadData(dl, "testLookupBatteryIdAddDescShort", cacheFlag);

		TestGraph.queryAndCheckResults(sgJson, this, "/lookupBatteryIdAddDescShortResults.csv");
		
	}
	
	@Test
	public void testLookupBatteryId_lookupFails() throws Exception {
		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
	
		// Try URI lookup
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/lookupBatteryIdAddDesc.json");
		Dataset ds = new CSVDataset("src/test/resources/lookupBatteryIdAddDescShortData.csv", false);
		
		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);


		Table err = dl.getLoadingErrorReport();
		assertEquals(20, err.getNumRows());		
		assertTrue(err.getRowAsCSVString(5).toLowerCase().contains("uri lookup"));
	}
	
	@Test
	public void testLoadLookupFailTwoFound() throws Exception {
		
		// Lookup fails because two matching URI's are found
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryShortData.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import durabattery twice.  
		// Puts two copies of each cell (GUID URI)  on each battery (mapped URI)
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
		// second load
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		// the real test
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/lookupCellDuraBattery.json");
		// real test's load
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		
		if (err.getNumRows() != 20) {
			LocalLogger.logToStdErr("Expecting 20 error rows, found: \n" + err.toCSVString());
			fail();
		}
		assertTrue(err.toCSVString().toLowerCase().contains("uri lookup"));
		
	}
	
	@Test
	public void testLoadLookXNodes() throws Exception {
		// Look for a battery with three cells A1, B1, C1
		// Add a fourth new cell, D100
		// Tests lookup across SNode connections since it looks up a battery by three cell's ids.
		// It also tests that the lookup nodegroup is pruned properly
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import durabattery first4.  
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestDuraBatteryFirst4Results.csv");

		// the real test
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBatteryLookXNodes.json");
		ds = new CSVDataset("src/test/resources/loadTestDuraBatteryLookXNodesData.csv", false);
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestDuraBatteryLookXNodesResults.csv");
	}
	
	@Test
	public void testLoadLookXNodesTwoConn() throws Exception {
		doLoadLookXNodesTwoConn(false);
		doLoadLookXNodesTwoConn(true);
	}
	public void doLoadLookXNodesTwoConn(boolean cacheFlag) throws Exception {
		// Repeat testLoadLookXNodes() with an extra data connection graph
		// ingest into a different graph
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);

		// setup as normal
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import durabattery first4 as normal
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		loadData(dl, "doLoadLookXNodesTwoConn preload", cacheFlag);
		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestDuraBatteryFirst4Results.csv");

		// the real test.   Note that "both" means standard model + data
		SparqlEndpointInterface seiBoth = TestGraph.getSei();
		SparqlEndpointInterface seiData0 = TestGraph.getSei(TestGraph.generateGraphName("data0"));
		seiData0.clearGraph();
		
		SparqlConnection connBothPlusData0 = TestGraph.getSparqlConn();
		connBothPlusData0.clearDataInterfaces();
		connBothPlusData0.addDataInterface(seiData0);
		connBothPlusData0.addDataInterface(seiBoth);
		
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBatteryLookXNodes.json");
		sgJson.setSparqlConn(connBothPlusData0);
		ds = new CSVDataset("src/test/resources/loadTestDuraBatteryLookXNodesData.csv", false);
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		loadData(dl, "doLoadLookXNodesTwoConn", cacheFlag);
		

		// query both graphs should get full results
		// query contains both + data0
		// New data should come back
		String query = TestGraph.getNodeGroupWithOInfo(sgJson).generateSparqlSelect();
		IntegrationTestUtility.querySeiAndCheckResults(query, seiBoth, this, "/loadTestDuraBatteryLookXNodesResults.csv");
		
		// generate query with only "both" sei in the FROM clause should only return original load
		// query only contains both (not data0)
		// new data shouldn't show up
		// original first4 should still return just those 4
		sgJson.setSparqlConn(TestGraph.getSparqlConn());
		query = TestGraph.getNodeGroupWithOInfo(sgJson).generateSparqlSelect();
		IntegrationTestUtility.querySeiAndCheckResults(query, seiBoth, this, "/loadTestDuraBatteryFirst4Results.csv");
	}
	
	@Test
	public void testLoadConnectNodes() throws Exception {
		// Connect cell will id "D" to cell4 of batteries with ids: "nocells" and "three"
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import durabattery first4.  
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		// the real test
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/lookupBatteryConnectNodes.json");
		ds = new CSVDataset("src/test/resources/lookupBatteryConnectNodesData.csv", false);
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		TestGraph.queryAndCheckResults(sgJson, this, "/lookupBatteryConnectNodesResults.csv");
	}
	
	@Test
	public void testLookupByEnum() throws Exception {
		// lookup battery with cell1 and cell2 both blue, and change the assembly Date to 3/23/66 8:00
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import durabattery first4.  
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
		// the real test 
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestLookupByEnum.json");
		ds = new CSVDataset("src/test/resources/loadTestLookupByEnumData.csv", false);
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestLookupByEnumResults.csv");
	}
	
	@Test
	public void testLookupByEnumBlanks() throws Exception {
		// try looking up on two enums but one is blank.  throw error
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import durabattery first4.  
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
		// the real test : look up battery by two colors and add assembly date.  But one color is blank.
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestLookupByEnum.json");
		ds = new CSVDataset("src/test/resources/loadTestLookupByEnumBlanksData.csv", false);
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		// make sure there's an error on URI lookup
		if (err.getNumRows() != 1) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		assertTrue(err.toCSVString().contains("ookup"));
	}
	
	@Test
	public void testLookupPruneBlanks() throws Exception {
		
		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		
		// the real test : look up battery by two colors and add assembly date.  But one color is blank.
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestLookupPruneBlanks.json");
		CSVDataset ds = new CSVDataset("src/test/resources/loadTestLookupPruneBlanks.csv", false);
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		
		// no errors
		if (err.getNumRows() != 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
		// load it again, just for grins.  Nothing should happen.
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		
		// no errors
		if (err.getNumRows() != 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
		// test results
		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestLookupPruneBlanksResults.csv");


	}
	@Test
	public void testLookupCreate() throws Exception {
		//  lookup Fails:    create 4 new batteries with assemglyDate, batteryDesc, batteryId
		//  lookup Succeeds: add assemblyDate to battery with batteryId="onlycolor"
		//  leave alone:     batteryId=three should remain un-changed
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import durabattery first4.  
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
		// the real test  
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestLookupCreate.json");
		ds = new CSVDataset("src/test/resources/loadTestLookupCreateData.csv", false);
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		if (err.getNumRows() != 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestLookupCreateResults.csv");
	}
	
	@Test
	public void testLookupCreateNOPROPS() throws Exception {
		//  Just like testLookupCreate
		//  Except ingestion nodegroup has no return values, no sparqlIDs on the properties
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import durabattery first4.  
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
		// the real test  
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestLookupCreate_NOPROPS.json");
		ds = new CSVDataset("src/test/resources/loadTestLookupCreateData.csv", false);
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		if (err.getNumRows() != 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestLookupCreate.json");
		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestLookupCreateResults.csv");
	}
	
	@Test
	public void testLookupSuperclass() throws Exception {
		//  Load lookup by superclass
		//  and make sure the superclass type is not ingested as a second type for the existing object
		//  pet_ingest_pet_nicknames.json also tests the "return type" feature of the select query
		
		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/Pet.owl");
		SparqlGraphJson sgJson1 = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/pet_ingest_cat_info.json");
		SparqlGraphJson sgJson2 = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/pet_ingest_pet_nicknames.json");
		Dataset ds1 = new CSVDataset("src/test/resources/pet_cat_info.csv", false);
		Dataset ds2 = new CSVDataset("src/test/resources/pet_nicknames.csv", false);

		// extra debugging
		LocalLogger.logToStdErr("Extra: sgJson1 sparql conn ------------");
		LocalLogger.logToStdErr(sgJson1.getSparqlConn().toString());
		
		LocalLogger.logToStdErr("Extra: TestGraph sparql conn ------------");
		LocalLogger.logToStdErr(TestGraph.getSparqlConn().toString());
		
		LocalLogger.logToStdErr("Extra: sgJson1 classes  ------------");
		OntologyInfo oInfo = new OntologyInfo(sgJson1.getSparqlConn());
		LocalLogger.logToStdErr(oInfo.getClassNames().toString());
		
		LocalLogger.logToStdErr("Extra: TestGraph classes  ------------");
		OntologyInfo oInfo1 = new OntologyInfo(TestGraph.getSparqlConn());
		LocalLogger.logToStdErr(oInfo1.getClassNames().toString());
		// end extra debugging
		
		// import cat info using class "Cat".  Unexplained test failure on next line on vesuvius-test
		DataLoader dl = new DataLoader(sgJson1, ds1, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
		// now add nicknames using URI lookup on superclass "Pet"
		
		dl = new DataLoader(sgJson2, ds2, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		if (err.getNumRows() != 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		// test that cat's don't have double type Pet
		// sgJson2 does double-duty ingesting and this select query
		TestGraph.queryAndCheckResults(sgJson2, this, "/pet_nickname_results.csv");
	}
	
	
	@Test
	public void testLookupCreatePartial() throws Exception {
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import durabattery first4.  
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
		// the real test  
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestLookupCreatePartial.json");
		ds = new CSVDataset("src/test/resources/loadTestLookupCreatePartialData.csv", false);
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		if (err.getNumRows() != 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
		// check that results match expected in csv
		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestLookupCreatePartialResults.csv");
		
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBatteryCellIdQuery.json");
		String query = TestGraph.getNodeGroupWithOInfo(sgJson).generateSparql(AutoGeneratedQueryTypes.QUERY_COUNT, false, -1, null);
		Table tab = TestGraph.runQuery(query);
		assertEquals(7, tab.getCellAsInt(0, 0));
	}
	
	
	@Test
	public void testCaseTransform() throws Exception {
		// Paul
		// Test string with \r and \n

		String uri = "testCaseTransform";
		String guy = "fred";
		String stuff = "STUFF";
		// set up the data
		String contents = "cell,size in,lot,material,guy,treatment\n" + String.format("%s,,,%s,%s,", uri, stuff, guy);

		Dataset ds = new CSVDataset(contents, true);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/testTransforms.owl");

		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/testTransforms.json");

		// calculate expected uri after applying transform. Capitalize all the
		// "E"s in the column value but not the text "Cell_"
		String prefix = sgJson.getImportSpec().getUriPrefix();
		uri = prefix + "Cell_" + uri.replaceAll("e", "E");


		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			fail(err.toCSVString());
		}

		// look for triples

		NodeGroup nodegroup = TestGraph.getNodeGroupWithOInfo(sgJson);
		returnProp(nodegroup, "Cell", "cellId");
		returnProp(nodegroup, "ScreenPrinting", "pasteVendor");
		returnProp(nodegroup, "ScreenPrinting", "pasteMaterial");
		constrainUri(nodegroup, "Cell", uri);

		String query = nodegroup.generateSparql(AutoGeneratedQueryTypes.QUERY_DISTINCT, false, null, null, false);

		Table tab = TestGraph.runQuery(query);
		if (tab.getNumRows() < 1) {
			throw new Exception("No triples were found for uri: " + uri);
		}

		// check first pasteVendor
		String answer;
		guy = guy.toUpperCase();
		stuff = stuff.toLowerCase();
		answer = tab.getRow(0).get(tab.getColumnIndex("pasteVendor"));
		if (!answer.equals(guy)) {
			fail(String.format("Inserted wrong string: %s expecting %s ", answer, guy));
		}
		answer = tab.getRow(0).get(tab.getColumnIndex("pasteMaterial"));
		if (!answer.equals(stuff)) {
			fail(String.format("Inserted wrong string: %s expecting %s ", answer, stuff));
		}
	}	
	
	
	@Test
	public void testGraphLoadBattery() throws Exception {
		SparqlGraphJson sgJson = TestGraph.initGraphWithData(this.getClass(), "sampleBattery");
		CSVDataset csvDataset = new CSVDataset("src/test/resources/sampleBattery.csv", false);
		DataLoader dl = new DataLoader(sgJson, csvDataset, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		assertEquals(dl.getTotalRecordsProcessed(), 4);
		TestGraph.queryAndCheckResults(sgJson, this, "/sampleBatteryResults.csv");
	}
	

	@Test
	public void testGraphLoadBadEnum() throws Exception {
		String csvPath = "src/test/resources/sampleBatteryBadColor.csv";
		String jsonPath = "src/test/resources/sampleBattery.json";
		String owlResource = "/sampleBattery.owl";

		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile(jsonPath);
		CSVDataset csvDataset = new CSVDataset(csvPath, false);
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, owlResource);

		DataLoader dl = new DataLoader(sgJson, csvDataset, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		String report = dl.getLoadingErrorReportBrief();

		// make sure there is a complaint about the bad color
		assertTrue(report.contains("whiteish-yellow"));
		assertTrue(dl.getTotalRecordsProcessed() == 0);
	}
	
	@Test
	public void testLookupCreateWithMapping() throws Exception {
		//  lookup Fails:    create 4 new batteries with assemglyDate, batteryDesc, batteryId
		//  lookup Succeeds: add assemblyDate to battery with batteryId="onlycolor" retaining original URI
		//  leave alone:     three others should remain un-changed
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import durabattery first4.  
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
		// the real test  
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestLookupCreateWMap.json");
		ds = new CSVDataset("src/test/resources/loadTestLookupCreateData.csv", false);
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		if (err.getNumRows() != 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestLookupCreateWMapResults.csv");
	}
	
	@Test
	public void testLookupCreateWithMappingFail() throws Exception {
		//  Try lookup by id that doesn't exist.  CreateIfMissing with a mapping.
		//  But the mapping uses description, and two rows have same id but diff mapping
		//  So it should fail on conflicting URI's for same lookup.
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

	  
		DataLoader dl;
		Table err;
		
		// the real test  
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestLookupCreateWMapFail.json");
		ds = new CSVDataset("src/test/resources/loadTestLookupCreateWMapFailData.csv", false);
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		if (err.getNumRows() != 1 || !err.getCell(0, 4).contains("Can't create a URI with two different values")) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
	}
	
	@Test
	public void test_TypesAndConstraintsViaBook() throws Exception {
		doTypesAndConstraintsViaBook(false);
		doTypesAndConstraintsViaBook(true);
	}
	
	public void doTypesAndConstraintsViaBook(boolean cacheFlag) throws Exception {  
		// Test important parts of RDF1.1 literal typing
		// with semtk load and semtk query
		Dataset ds = new CSVDataset("src/test/resources/book.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/book.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromResource(this, "/book.json");

		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		
		loadData(dl, "doTypesAndConstraintsViaBook", cacheFlag);

		TestGraph.queryAndCheckResults(sgJson, this, "/bookResults.csv");
		
		queryBook("?title", 
				SupportedOperations.MATCHES, 
				new String[] {"Typed Raw SPARQL","Untyped Raw SPARQL","Ingested"});
		queryBook("?title", 
				SupportedOperations.REGEX, 
				new String[] {"e"});
		queryBook("?publishDate", 
				SupportedOperations.MATCHES, 
				new String[] {"1963-03-03"});
		queryBook("?publishDate", 
				SupportedOperations.GREATERTHAN, 
				new String[] {"1960-01-01"});
		queryBook("?publishDateTime", 
				SupportedOperations.MATCHES, 
				new String[] {"1961-01-01T01:00:00","1962-02-02T02:00:00","1963-03-03T03:00:00"});
		queryBook("?publishDateTime", 
				SupportedOperations.GREATERTHAN, 
				new String[] {"1960-01-01T01:00:00"});
		queryBook("?pages", 
				SupportedOperations.MATCHES, 
				new String[] {"300"});
		queryBook("?pages", 
				SupportedOperations.GREATERTHAN, 
				new String[] {"10"});
		queryBook("?price", 
				SupportedOperations.MATCHES, 
				new String[] {"30.99"});
		queryBook(
				"?price", 
				SupportedOperations.GREATERTHAN, 
				new String[] {"9.99"});


	}
	
	/**
	 * Build runtime constraint and run query, expecting all three books to come back
	 * @param sparqlID
	 * @param operator
	 * @param operandList
	 * @throws Exception
	 */
	private void queryBook(String sparqlID, SupportedOperations operator, String [] operandList) throws Exception {
		SparqlGraphJson sgjson = TestGraph.getSparqlGraphJsonFromResource(this, "/book.json");
		String constraintSparql = TestGraph.addRuntimeConstraint(sgjson, sparqlID, operator, operandList);
		System.out.println("   " + constraintSparql);
		// run the query
		Table tab = TestGraph.execTableSelect(sgjson);
		assertEquals("With runtime constraint: \n" + constraintSparql + "\nQuery did not return one book: \n" + tab.toCSVString(), 1, tab.getNumRows());
	}
	
	
	// fails if we don't set SparqlID
	// fails if SparqlID doesn't start with "?"
	private void returnProp(NodeGroup nodegroup, String node, String prop) throws Exception {
		PropertyItem cellId = nodegroup.getNodeBySparqlID("?" + node).getPropertyByKeyname(prop);
		cellId.setSparqlID("?" + prop);
		cellId.setIsReturned(true);
	}

	private void constrainPropRegex(NodeGroup nodegroup, String node, String prop, String regex) throws Exception{
		PropertyItem propItem = nodegroup.getNodeBySparqlID("?" + node).getPropertyByKeyname(prop);
		ValueConstraint constraint = new ValueConstraint(ValueConstraint.buildRegexConstraint(propItem.getSparqlID(), regex, propItem.getValueType()));
		propItem.setValueConstraint(constraint);
	}
	
	private void constrainUri(NodeGroup nodegroup, String nodeUri, String constraintUri) {
		Node node = nodegroup.getNodeBySparqlID("?" + nodeUri);
		ValueConstraint v = new ValueConstraint(String.format("VALUES ?Cell { <%s> } ", constraintUri));
		node.setValueConstraint(v);
	}

	
	private void loadData(DataLoader dl, String logName, boolean cacheFlag) throws Exception {
		if (!cacheFlag)
			dl.doNotCache();

		long start = IntegrationTestUtility.getStartTime();
		dl.importData(true);
		String entry = IntegrationTestUtility.logDuration(start, "TIMING " + logName + (cacheFlag ? " with cache" : " w/o  cache"));
		timingMessages.add(entry);
		
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
	}
}
