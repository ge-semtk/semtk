/**
 ** Copyright 2019 General Electric Company
 **
 **
 ** Licensed under the Apache License, Version 2.0 (the "License");
 ** you may not use this file except in compliance with the License.
 ** You may obtain a copy of the License at
 ** 
 **     http://www.apache.org/licenses/LICENSE-2.0
 ** 
 ** Unless required by applicable law or agreed to in writing, software
 ** distributed under the License is distributed on an "AS IS" BASIS,
 ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ** See the License for the specific language governing permissions and
 ** limitations under the License.
 */

package com.ge.research.semtk.load.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;


import org.apache.commons.io.FileUtils;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Hashtable;
import java.util.List;

import com.ge.research.semtk.api.nodeGroupExecution.client.NodeGroupExecutionClient;
import com.ge.research.semtk.belmont.AutoGeneratedQueryTypes;
import com.ge.research.semtk.belmont.Node;
import com.ge.research.semtk.belmont.NodeGroup;
import com.ge.research.semtk.belmont.PropertyItem;
import com.ge.research.semtk.belmont.ValueConstraint;
import com.ge.research.semtk.belmont.runtimeConstraints.SupportedOperations;
import com.ge.research.semtk.edc.client.ResultsClient;
import com.ge.research.semtk.edc.client.StatusClient;
import com.ge.research.semtk.load.DataLoader;
import com.ge.research.semtk.load.dataset.CSVDataset;
import com.ge.research.semtk.load.dataset.Dataset;
import com.ge.research.semtk.load.utility.SparqlGraphJson;
import com.ge.research.semtk.ontologyTools.OntologyInfo;
import com.ge.research.semtk.resultSet.SimpleResultSet;
import com.ge.research.semtk.resultSet.Table;
import com.ge.research.semtk.sparqlX.SparqlConnection;
import com.ge.research.semtk.sparqlX.SparqlEndpointInterface;
import com.ge.research.semtk.sparqlX.client.SparqlQueryClient;
import com.ge.research.semtk.sparqlX.dispatch.client.DispatchRestClient;
import com.ge.research.semtk.test.IntegrationTestUtility;
import com.ge.research.semtk.test.TestGraph;
import com.ge.research.semtk.utility.LocalLogger;

/**
 * These are the main / large data loading tests.
 * 
 * Testing data loading WITHOUT SERVICE LAYER.
 * This is only "_IT" integration test because of the triple-store
 * @author 200001934
 *
 */
public class DataLoaderTest_IT {
	private static ArrayList<String> timingMessages = new ArrayList<String>();
	
	@BeforeClass
	public static void setup() throws Exception {
		IntegrationTestUtility.authenticateJunit();
	}
	
	@AfterClass
	public static void shutdown() throws Exception {
		Collections.sort(timingMessages);
		for (String s : timingMessages) {
			System.out.println(s);
		}
	}
	@Test
	public void testOriginal() throws Exception {
		Dataset ds = new CSVDataset("src/test/resources/testTransforms.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/testTransforms.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/testTransforms.json");

		// test
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			fail(err.toCSVString());
		}
		assertEquals(dl.getTotalRecordsProcessed(), 3);
	}	
	
	@Test
	public void testLoadFromCsv() throws Exception {

		String owlResource = "/testTransforms.owl";
		
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, owlResource);
		SparqlConnection conn = TestGraph.getSparqlConn();

		String templateFilePath = "src/test/resources/testTransforms.json";
		String csvFilePath = "src/test/resources/testTransforms.csv";
		
		boolean exceptionThrown = false;
		
		// confirm errors if not a json file
		exceptionThrown = false;
		try{
			DataLoader.loadFromCsv("file.notjson", csvFilePath, TestGraph.getUsername(), TestGraph.getPassword(), conn);
		}catch(Exception e){
			exceptionThrown = true;
			assertTrue(e.getMessage().contains("file.notjson is not a JSON file"));
		}
		assertTrue(exceptionThrown);
		
		// confirm errors if json file not found
		exceptionThrown = false;
		try{
			DataLoader.loadFromCsv("file.json", csvFilePath, TestGraph.getUsername(), TestGraph.getPassword(), conn);
		}catch(Exception e){
			exceptionThrown = true;
			assertTrue(e.getMessage().contains("Could not load JSON from file file.json"));
		}
		assertTrue(exceptionThrown);
		
		// confirm errors if not a csv file
		exceptionThrown = false;
		try{
			DataLoader.loadFromCsv(templateFilePath, "file.notcsv", TestGraph.getUsername(), TestGraph.getPassword(), conn);
		}catch(Exception e){
			exceptionThrown = true;
			assertTrue(e.getMessage().contains("file.notcsv is not a CSV file"));
		}
		assertTrue(exceptionThrown);
		
		// confirm errors if csv file not found
		exceptionThrown = false;
		try{
			DataLoader.loadFromCsv(templateFilePath, "file.csv", TestGraph.getUsername(), TestGraph.getPassword(), conn);
		}catch(Exception e){
			exceptionThrown = true;
			assertTrue(e.getMessage().contains("file.csv"));
		}
		assertTrue(exceptionThrown);
		
		// confirm works, using connection override
		int numRecordsAdded = DataLoader.loadFromCsv(templateFilePath, csvFilePath, TestGraph.getUsername(), TestGraph.getPassword(), conn);
		assertEquals(numRecordsAdded, 3);	// loaded 3 csv rows
		assertEquals(147, TestGraph.getNumTriples());  // confirmed that the graph got all the data
		
		// confirm can delete a directory containing a CSV file that has been loaded
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, owlResource);

		String tmpDirToDelete = "src/test/resources/tmpToDelete/";     			// create a directory that we can later delete
		String csvFileToDelete = tmpDirToDelete + "testTransforms.csv";
		FileUtils.copyFile(new File(csvFilePath),new File(csvFileToDelete));	// copy a CSV file here
		numRecordsAdded = DataLoader.loadFromCsv(templateFilePath, csvFileToDelete, TestGraph.getUsername(), TestGraph.getPassword(), conn);
		assertEquals(numRecordsAdded, 3);	// loaded 3 csv rows
		assertEquals(TestGraph.getNumTriples(), 147);  // confirmed that the graph got all data
		FileUtils.deleteDirectory(new File(tmpDirToDelete));  // will throw exception if fails
		
	}
	
	@Test
	public void testTransforms() throws Exception {
		// Paul
		// Test that a transform is applied properly to a column value but NOT
		// to the adjacent text

		// set up the data
		String contents = "cell,size in,lot,material,guy,treatment\n"
				+ "abcde_test,,,,,\n";
		Dataset ds = new CSVDataset(contents, true);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/testTransforms.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/testTransforms.json");

		// calculate expected uri after applying transform. Capitalize all the
		// "E"s in the column value but not the text "Cell_"
		String prefix = sgJson.getImportSpecHandler().getUriPrefix();
		String uri = prefix + "Cell_abcdE_tEst";

		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			fail(err.toCSVString());
		}

		// look for triples
		SparqlEndpointInterface sei = TestGraph.getSei();
		Table table = sei.executeQueryToTable(TestGraph.getNodeGroupWithOInfo(sgJson).generateSparqlSelect());
		assertTrue(table.toCSVString().contains(uri));
	}
	
	@Test
	public void testBadUri() throws Exception {
		// Paul
		// Test uri with spaces and <> to make sure it is escaped properly

		// set up the data
		String contents = "Battery,Cell,birthday,color\n"
				+ "<contains space and brackets>,cellA,01/01/1966,red\n";

		//String CORRECT = "Cell_%3Ccontains%20spacE%20and%20brackEts%3E";
		Dataset ds = new CSVDataset(contents, true);

		// get json
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/sampleBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromResource(this, "sampleBattery.json");

		// calculate expected uri after applying transform. Capitalize all the
		// "E"s in the column value but not the text "Cell_"
		//String prefix = sgJson.getImportSpec().getUriPrefix();

		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());

		int records = dl.importData(true);
		assertTrue(records == 0);
		assertTrue(dl.getLoadingErrorReport().getRow(0).get(4).contains("ill-formed URI"));
	}	
	
	// Validation:  these test basic integration.  DataLoaderTest_IT tests details of validation.
	@Test
	public void testValidatePasses() throws Exception { 

		// set up the data
		String contents = "Battery,Cell,birthday,color\n"
				+ "MyBattery,cellA,01/01/1966,red\n";
		Dataset ds = new CSVDataset(contents, true);

		// get json
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/sampleBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromResource(this, "sampleBattery_ValidateDateRed.json");

		
		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());

		int records = dl.importData(true);
		assertEquals(dl.getLoadingErrorReport().toCSVString(), 1, records);
	}	
	
	// Validation:  these test basic integration.  DataLoaderTest_IT tests details of validation.
	@Test
	public void testValidateSpecialCharacterStr() throws Exception { 

		// set up the data
		String contents = "Battery,Cell,birthday,color\n"
				+ "BatteryName, cell-micron-Î¼m,01/01/1966,red\n";
		Dataset ds = new CSVDataset(contents, true);

		// get json
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/sampleBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromResource(this, "sampleBattery_ValidateDateRed.json");

		
		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());

		int records = dl.importData(true);
		assertEquals(dl.getLoadingErrorReport().toCSVString(), 1, records);
		
		Table resTab = TestGraph.execTableSelect(sgJson);
		assertTrue(resTab.getCellAsString(0, 1).equals("cell-micron-Î¼m"));
		System.out.println(resTab.toCSVString());
		System.out.println(resTab.toJson());
	}	
	

	@Test
	public void testValidateSpecialCharacterFile() throws Exception { 

		// set up the data
		CSVDataset csv = new CSVDataset("src/test/resources/sampleBatteryNonAscii.csv", false);

		// get json
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/sampleBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromResource(this, "sampleBattery_ValidateDateRed.json");

		
		// import
		DataLoader dl = new DataLoader(sgJson, csv, TestGraph.getUsername(), TestGraph.getPassword());

		int records = dl.importData(true);
		assertEquals(dl.getLoadingErrorReport().toCSVString(), 1, records);
		
		Table resTab = TestGraph.execTableSelect(sgJson);
		assertTrue(resTab.getCellAsString(0, 1).equals("cell-micron-Î¼m"));
		System.out.println(resTab.toCSVString());
		System.out.println(resTab.toJson());
	}	
	
	// Validation:  these test basic integration.  DataLoaderTest_IT tests details of validation.
	@Test
	public void testValidateFailsMissingCol() throws Exception { 

		// set up the data
		String contents = "Battery,Cell,birthday\n"
				+ "MyBattery,cellA,01/01/1966\n";
		Dataset ds = new CSVDataset(contents, true);

		// get json
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/sampleBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromResource(this, "sampleBattery_ValidateDateRed.json");

		
		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());

		int records = dl.importData(true);
		// fails because column "color" is missing
		assertEquals(dl.getLoadingErrorReport().toCSVString(), 0, records);
		assertTrue(dl.getLoadingErrorReport().toCSVString().contains("color"));
	}	
	@Test
	public void testValidateFailsColorRed() throws Exception { 

		// set up the data
		String contents = "Battery,Cell,birthday,color\n"
				+ "MyBattery,cellA,01/01/1966,FAIL\n";
		Dataset ds = new CSVDataset(contents, true);

		// get json
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/sampleBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromResource(this, "sampleBattery_ValidateDateRed.json");

		
		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());

		int records = dl.importData(true);
		// fails because FAIL doesn't match the regex red
		assertEquals(dl.getLoadingErrorReport().toCSVString(), 0, records);
		assertTrue(dl.getLoadingErrorReport().toCSVString().contains("FAIL"));

	}	
	
	@Test
	public void testBoolean() throws Exception {
		// set up the data
		String contents = "Happy,name\n"
				+ "true,HappyGuy\n"
				+ "false,SadGuy\n";
		Dataset ds = new CSVDataset(contents, true);

		// get json
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/SimpleBoolean.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromResource(this, "SimpleBoolean.json");


		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());

		int records = dl.importData(true);
		assertEquals("Did not load expected records", 2, records);
		
		Table t = TestGraph.execTableSelect(sgJson);
		List<String> col = Arrays.asList(t.getColumn("Happy"));
		assertTrue("Can't find the ingested value: true", col.contains("true"));
		assertTrue("Can't find the ingested value: false", col.contains("false"));

		///////// Now fail ///////////
		contents = "Happy,name\n"
				+ "t,HappyGuy\n"
				+ "1,HappyGuy\n"
				+ "Yes,HappyGuy\n"
				+ "frog,SadGuy\n";
		ds = new CSVDataset(contents, true);
			
		// import
		DataLoader dl2 = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		records = dl2.importData(true);
		assertEquals("Did not load expected boolean load failures", 4, dl2.getLoadingErrorReport().getNumRows());
	}
	
	@Test
	public void testMessyString1() throws Exception {
		// Test string with \r and \n
		String uri = "testMessyString"; // avoid the uppercasing transform by using uppercase
		String pastelot = "This is a messy\n string \r\n line3\n";
		String contents = "cell,size in,lot,material,guy,treatment\n" + uri 	+ ",,\"" + pastelot + "\",,,\n";

		Dataset ds = new CSVDataset(contents, true);

		// get json
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/testTransforms.json");

		// calculate expected uri after applying transform. Capitalize all the "E"s in the column value but not the text "Cell_"
		String prefix = sgJson.getImportSpecHandler().getUriPrefix();
		uri = prefix + "Cell_" + uri.replaceAll("e", "E");

		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/testTransforms.owl");

		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			fail(err.toCSVString());
		}

		// look for triples
		NodeGroup nodegroup = TestGraph.getNodeGroupWithOInfo(sgJson);
		constrainUri(nodegroup, "Cell", uri);
		returnProp(nodegroup, "Cell", "cellId");
		returnProp(nodegroup, "ScreenPrinting", "pasteLot");

		String query = nodegroup.generateSparql(AutoGeneratedQueryTypes.SELECT_DISTINCT, false, null, null, false);

		Table tab = TestGraph.runQuery(query);
		if (tab.getNumRows() < 1) {
			throw new Exception("No triples were found for uri: " + uri);
		}

		// check first pasteLot
		String answer = tab.getCell(0, "pasteLot");
		if (!answer.equals(pastelot)) {
			fail(String.format("Inserted wrong string: '%s' expecting '%s' ", answer, pastelot));
		}
	}
	
	
	@Test
	public void testMessyStringsInCsv() throws Exception {
		// Reads strings out of testStrings.csv
		//
		// Adding more test cases:
		// Fill in only the two columns already used
		// Make sure "cell" starts with "testStrings" and is unique
		// Then "lot" should be the string to be tested
		// get the csv
		Dataset ds = new CSVDataset("src/test/resources/testStrings.csv", false);
		CSVDataset csv = new CSVDataset("src/test/resources/testStrings.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/testTransforms.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/testTransforms.json");

		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			fail(err.toCSVString());
		}

		NodeGroup ng = TestGraph.getNodeGroupWithOInfo(sgJson);
		ng.appendOrderBy("?Cell");
		returnProp(ng, "Cell", "cellId");
		returnProp(ng, "ScreenPrinting", "pasteLot");
		constrainPropRegex(ng, "Cell", "cellId", "^testStrings");
		String query = ng.generateSparqlSelect();

		// --------------------------------------------------
		// Test the messy strings through the sei
		// --------------------------------------------------
		Table tab = TestGraph.runQuery(query);
		if (tab.getNumRows() < 1) {
			throw new Exception("No triples were found for uri: "); // + uri);
		}

		// put all expected results into a hashtable
		Hashtable<String, String> correct = new Hashtable<String, String>();
		ArrayList<ArrayList<String>> rows = csv.getNextRecords(1000);
		for (int i = 0; i < rows.size(); i++) {
			correct.put(rows.get(i).get(0), rows.get(i).get(2));
		}

		// loop through actual results
		for (int i = 0; i < tab.getNumRows(); i++) {
			String key = tab.getRow(i).get(1);
			String actual = tab.getRow(i).get(2);
			String expect = correct.get(key);

			// no substitutions are expected
			//expect = expect.replace("\\n", "\n");
			//expect = expect.replace("\\t", "\t");

			if (!actual.equals(expect)) {
				fail(String.format(
						"Bad string retrieved.  Expecting '%s' Found '%s'",	expect, actual));
			}
		}
		
		// ------------------------------------------------------------------------
		// Re-test the messy strings through the dispatch and results web clients
		// ------------------------------------------------------------------------
		DispatchRestClient dclient = IntegrationTestUtility.getDispatchRestClient();
		ResultsClient rclient = IntegrationTestUtility.getResultsClient();
		SimpleResultSet res = dclient.executeRawSparqlQuery(TestGraph.getSparqlAuthConn(), query);
		assertTrue(res.getSuccess());
		String jobId = res.getJobId();
		StatusClient sclient = IntegrationTestUtility.getStatusClient(jobId);
		sclient.waitForCompletionSuccess();
		
		CSVDataset csvFromResultsClient = rclient.getTableResultsCSV(jobId, 100);
		ArrayList<ArrayList<String>> recordsFromQuery = csvFromResultsClient.getNextRecords(100);
		csv.reset();
		ArrayList<ArrayList<String>> recordsFromFile = csv.getNextRecords(100);
		for (int r = 0; r < recordsFromFile.size(); r++) {
			int c = 2;
			String before = recordsFromFile.get(r).get(c);
			String after = recordsFromQuery.get(r).get(c);
			assertTrue("Round trip through web client mismatch.  before: " + before  + " after: " + after, after.equals(before) );
		
		}
	}
	
	
	@Test
	public void testTrimSpacesInCsv() throws Exception {

		SparqlGraphJson sgJson = TestGraph.initGraphWithData(this.getClass(), "sampleBattery");
		CSVDataset csvDataset = new CSVDataset("src/test/resources/sampleBatteryManySpaces.csv", false);
		DataLoader dl = new DataLoader(sgJson, csvDataset, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		assertEquals(dl.getTotalRecordsProcessed(), 4);
		TestGraph.queryAndCheckResults(sgJson, this, "/sampleBatteryResults.csv");

	}
	@Test
	public void test_LoadData() throws Exception {
		doLoadData(false);
		doLoadData(true);
	}
	
	public void doLoadData(boolean cacheFlag) throws Exception {

		// Pre changes:   19.5s 18.5s  18.64s  17.514
		// During changes:  
		// Bigger-ish test of many import spec features and timing
		Dataset ds = new CSVDataset("src/test/resources/loadTestData.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTest.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTest.json");

		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		loadData(dl, "doLoadData", cacheFlag);

		assertEquals(dl.getTotalRecordsProcessed(), 1998);
		
		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestResults.csv");
		
	}
	
	@Test
	public void testLoadWithBindings() throws Exception {
		
		Dataset ds = new CSVDataset("src/test/resources/loadTestData.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTest.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTest.json");

		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		loadData(dl, "doLoadData no bindings", true);

		assertEquals(dl.getTotalRecordsProcessed(), 1998);
		
		long start = IntegrationTestUtility.getStartTime();
		Table tab = TestGraph.execTableSelect(sgJson);
		String entry = IntegrationTestUtility.logDuration(start, "TIMING " + "query no bindings");
		timingMessages.add(entry);
		
		/////// Add bindings and try again ///////////
		NodeGroup ng = sgJson.getNodeGroup();
		Node cell = ng.getNodeBySparqlID("Cell");
		ng.setIsReturned(cell, false);
		ng.setBinding(cell, "Cell_renamed");
		ng.setBindingIsReturned(cell, true);
		
		PropertyItem cellId = cell.getPropertyByKeyname("cellId");
		ng.setIsReturned(cellId, false);
		ng.setBinding(cellId, "cellId_renamed");
		ng.setBindingIsReturned(cellId, true);
		
		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTest.owl");

		// import
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		loadData(dl, "doLoadData w/ bindings", true);

		assertEquals(dl.getTotalRecordsProcessed(), 1998);
		
		// run the query
		start = IntegrationTestUtility.getStartTime();
		tab = TestGraph.execTableSelect(sgJson);
		entry = IntegrationTestUtility.logDuration(start, "TIMING " + "query w/ bindings");
		timingMessages.add(entry);
	}
	
	@SuppressWarnings("deprecation")
	@Test
	public void testLoadDataSmallBatch() throws Exception {
		// Pre changes:   19.5s 18.5s  18.64s  17.514
		// During changes:  
		// Bigger-ish test of many import spec features and timing
		Dataset ds = new CSVDataset("src/test/resources/loadTestData.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTest.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTest.json");

		// import with stupid small starting batch size
		DataLoader dl = new DataLoader(sgJson, 1, ds, TestGraph.getUsername(), TestGraph.getPassword());
		
		LocalLogger.logToStdOut("Starting load");
		dl.importData(true);
		LocalLogger.logToStdOut("Finished with load");
		
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		assertEquals(dl.getTotalRecordsProcessed(), 1998);
		
		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestResults.csv");
		
	}
	
	@SuppressWarnings("deprecation")
	@Test
	public void testLoadDataLargeBatch() throws Exception {
		// Pre changes:   19.5s 18.5s  18.64s  17.514
		// During changes:  
		// Bigger-ish test of many import spec features and timing
		Dataset ds = new CSVDataset("src/test/resources/loadTestData.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTest.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTest.json");

		// import with stupid big starting batch size
		DataLoader dl = new DataLoader(sgJson, 10000, ds, TestGraph.getUsername(), TestGraph.getPassword());
		
		LocalLogger.logToStdOut("Starting load");
		dl.importData(true);
		LocalLogger.logToStdOut("Finished with load");
		
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		assertEquals(dl.getTotalRecordsProcessed(), 1998);
		
		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestResults.csv");
		
	}
	
	@Test
	public void testLoadDataMessyBaseURI() throws Exception {
		// baseURI ends with "#".  (caused a buggy ingest in the past)
		
		Dataset ds = new CSVDataset("src/test/resources/loadTestData.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTest.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestMessyBaseURI.json");
		
		// import 
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		
		LocalLogger.logToStdOut("Starting load");
		dl.importData(true);
		LocalLogger.logToStdOut("Finished with load");
		
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		assertEquals(dl.getTotalRecordsProcessed(), 1998);
		
		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestResults.csv");
		
	}
	@Test
	public void testPrecheckOnly() throws Exception {
		Dataset ds = new CSVDataset("src/test/resources/loadTestDataShort.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTest.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTest.json");

		// precheck
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true, true);  // skip ingest
		
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		// check that no records were loaded
		assertEquals(dl.getTotalRecordsProcessed(), 0); 
		
		// check that results are empty
		TestGraph.queryAndCheckResults(sgJson, this, "/testPrecheckOnlyResults.csv");
	}
	
	/*
	 * What-were-we-thinking alert:
	 * loadTestDuraBattery.json creates Battery URI's or the form: Batt_<hash>_<batteryId>
	 * lookupBatteryIdAddDesc.json adds descriptions and queries
	 * 	BatteryURI
	 *  batteryId
	 *  desc
	 *  
	 *  So it is sorting on BatteryURI, a hash value.  This is deterministic/repeatable, but confusing.  Why?
	 * 
	 */
	@Test
	public void test_LoadDataDuraBattery() throws Exception {
		doLoadDataDuraBattery(false);
		doLoadDataDuraBattery(true);
	}
	
	public void doLoadDataDuraBattery(boolean cacheFlag) throws Exception {  
		// Bigger-ish test of many import spec features and timing. 
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryData.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		
		loadData(dl, "doLoadDataDuraBattery", cacheFlag);

		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestDuraBatteryResults.csv");
		
	}
	
	@Test
	public void testLoadDataIngestTime() throws Exception {
		// tests %ingestTime
		
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBatteryIngestTime.json");

		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		
		LocalLogger.logToStdOut("Starting load");
		dl.importData(true);
		LocalLogger.logToStdOut("Finished with load");
		
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		String query = TestGraph.getNodeGroupWithOInfo(sgJson).generateSparql(AutoGeneratedQueryTypes.SELECT_DISTINCT, false, 0, null);		
		Table tab = TestGraph.runQuery(query);
		String d = tab.getCellAsString(1, 1);
		if (d.endsWith("Z")) {
			d = d.substring(0, d.length()-5);
		}
		LocalDateTime sampleTime = LocalDateTime.parse(d);
		
		// make sure first time ingested and queried is within the last 1 minute
		LocalDateTime t2 = LocalDateTime.now().minusMinutes(1);
		assertTrue(sampleTime.compareTo(t2) > 0);
	}
	
	@Test
	public void testLoadDataDuraBatteryAsync() throws Exception {
		// Pre changes:   
		// During changes:  
		// Bigger-ish test of many import spec features and timing. 
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryData.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		
		String jobId = IntegrationTestUtility.generateJobId("testLoadDataDuraBatteryAsync");
		StatusClient sClient = IntegrationTestUtility.getStatusClient(jobId);
		ResultsClient rClient = IntegrationTestUtility.getResultsClient();
		try {
			dl.runAsync(true, false, sClient, rClient);
			
			int percent = 1;
			int lastPercent = 0;
			while (percent < 100 && percent > lastPercent) {
				lastPercent = percent;
				percent = sClient.execWaitForPercentOrMsec(100, 60000);
			}
			
			assertTrue("ingest bogged down for 60 seconds. Percent complete stuck at: " + String.valueOf(percent), percent == 100);
			assertTrue("ingest failed: " + sClient.execGetStatusMessage(), sClient.execIsSuccess());
		} finally {
			sClient.execDeleteJob();
		}

		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestDuraBatteryResults.csv");
		
	}
	
	@Test
	public void testLoadDataDuraBatteryEmptyCol() throws Exception {
		// Catch the error when a URI mappingItem column contains empty
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryData.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDBattEmptyCol.json");

		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		
		LocalLogger.logToStdOut("Starting load");
		dl.importData(true);
		LocalLogger.logToStdOut("Finished with load");
		
		Table err = dl.getLoadingErrorReport();
		assertEquals(1, err.getNumRows());
		assertTrue(err.toCSVString().contains("Empty values in"));
		assertTrue(err.toCSVString().contains("only colors"));
	}
	
	@Test
	public void testLoadDataDuraBatteryEmptyColAsync() throws Exception {
		// Catch the error when a URI mappingItem column contains empty
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryData.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDBattEmptyCol.json");

		String jobId = IntegrationTestUtility.generateJobId("testLoadDataDuraBatteryEmptyColAsync");
		StatusClient sClient = IntegrationTestUtility.getStatusClient(jobId);
		ResultsClient rClient = IntegrationTestUtility.getResultsClient();
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());

		try {
			dl.runAsync(true, false, sClient, rClient);

			int percent = 1;
			int lastPercent = 0;
			while (percent < 100 && percent > lastPercent) {
				lastPercent = percent;
				percent = sClient.execWaitForPercentOrMsec(100, 60000);
			}
			
			assertTrue("ingest bogged down for 60 seconds. Percent complete stuck at: " + String.valueOf(percent), percent == 100);
			assertTrue("ingest succeeded unexpectedly", !sClient.execIsSuccess());
			
			Table err = rClient.getTableResultsJson(jobId, 10000);
			assertEquals(1, err.getNumRows());
			assertTrue(err.toCSVString().contains("Empty values in"));
			assertTrue(err.toCSVString().contains("only colors"));
		} finally {
			sClient.execDeleteJob();
		}

		
	}
	
	@Test
	public void test_TypedString() throws Exception {
		
		doTypedString(true);   // FAILS with un-typed literals in jena dump
		doTypedString(false);
	}
	
	/**
	 * Insert a few lines
	 * Try to retrieve a typed literal string "onlycolor"^^XMLSchema:string
	 * (Make sure type isn't lost during cache process)
	 */
	public void doTypedString(boolean cacheFlag) throws Exception {
		// setup
		TestGraph.clearGraph();
				
		// ==== pre set some data =====
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson0 = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");
		Dataset ds0 = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);
		DataLoader dl0 = new DataLoader(sgJson0, ds0, TestGraph.getUsername(), TestGraph.getPassword());
		loadData(dl0, "doLookupBatteryIdAddDesc PRELOAD", cacheFlag);
		
		Table err0 = dl0.getLoadingErrorReport();
		if (err0.getNumRows() > 0) {
			fail(err0.toCSVString());
		}

		// run raw SPARQL to retrieve typed string in a FILTER clause
		Table t2 = TestGraph.runQuery(
				"prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#> " +
						"SELECT * FROM <"+ TestGraph.getSei().getGraph() + "> " + 
						"WHERE { ?s ?p ?o .  FILTER ( str(?o) = \"onlycolor\") }"
				);
		assertEquals("FILTER clause did not retrieve literal string when cacheFlag=" + (cacheFlag?"true":"false"), 1, t2.getNumRows());

				
		// run raw SPARQL to retrieve typed string in a VALUES clause
		Table t = TestGraph.runQuery(
				"prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#> " +
				"SELECT * FROM <"+ TestGraph.getSei().getGraph() + "> " + 
				"WHERE { ?s ?p ?o .  VALUES ?o {\"onlycolor\"^^XMLSchema:string } }"
				); 
		
		// now we know/accept that cache insert will indeed strip the type off strings
		System.out.println(
				"VALUES clause " + (t.getNumRows() == 0 ? "DID NOT ":"DID ") + 
				" retrieve literal string with FROM when cacheFlag=" + (cacheFlag?"true":"false") );
		
	}
	
	@Test
	public void test_LookupBatteryIdAddDesc() throws Exception {
		doLookupBatteryIdAddDesc(true);  
		doLookupBatteryIdAddDesc(false);
	}
	
	public void doLookupBatteryIdAddDesc(boolean cacheFlag) throws Exception {

		// setup
		TestGraph.clearGraph();
				
		// ==== pre set some data =====
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson0 = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");
		Dataset ds0 = new CSVDataset("src/test/resources/loadTestDuraBatteryData.csv", false);

		DataLoader dl0 = new DataLoader(sgJson0, ds0, TestGraph.getUsername(), TestGraph.getPassword());
		
		
		loadData(dl0, "doLookupBatteryIdAddDesc PRELOAD", cacheFlag);

		// It looks like when we insert via inMemory graph, the strings go in as plain literals.
		// InMemoryInterfaceTest_IT.testInsertSelectTypedString() shows they go into the in-memory graph ok.
		// test_TypedString() shows that cached load is failing to preserve type
		//
		// So the problem must be in dumping to OWL/RDF and uploading.   The Owl looks wrong.  
		//        <j.0:batteryId>id_733344685</j.0:batteryId>
		//    instead of
		//        <j.0:batteryId>"id_733344685"^^XMLSchema:string</j.0:batteryId>
		// When we do URI lookups, we query for "value"^^xsd:string
		//
		//   http://iswc2011.semanticweb.org/fileadmin/iswc/Papers/Workshops/SSWS/Emmons-et-all-SSWS2011.pdf
		//   	literal types are often handled inconsistently
		// 	    filter clause will probably work
		//
		// BEST: figure out how to dump to turtle since owl/rdf is too verbose AND wrong
		
				
				
		// Try URI lookup
		// This nodegroup has some cells that should be pruned
		// One cell has bindings
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/lookupBatteryIdAddDescXtras.json");

		Dataset ds = new CSVDataset("src/test/resources/lookupBatteryIdAddDescData.csv", false);
		
		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		loadData(dl, "doLookupBatteryIdAddDesc LOOKUP", cacheFlag);
		
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/lookupBatteryIdAddDesc.json");
		TestGraph.queryAndCheckResults(sgJson, this, "/lookupBatteryIdAddDescResults.csv");
		
	}
	
	
	@Test
	public void test_LookupSuperBatteryIdAddDesc() throws Exception {
		doLookupSuperBatteryIdAddDesc(true);  
		//doLookupSuperBatteryIdAddDesc(false);
	}
	
	/**
	 * Lookup is performed by superclass
	 * @param cacheFlag
	 * @throws Exception
	 */
	public void doLookupSuperBatteryIdAddDesc(boolean cacheFlag) throws Exception {
		// setup
		TestGraph.clearGraph();
				
		// ==== pre set some data =====
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson0 = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");
		Dataset ds0 = new CSVDataset("src/test/resources/loadTestDuraBatteryData.csv", false);

		DataLoader dl0 = new DataLoader(sgJson0, ds0, TestGraph.getUsername(), TestGraph.getPassword());
		
		loadData(dl0, "doLookupBatteryIdAddDesc PRELOAD", cacheFlag);	
				
		// Try URI lookup
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/lookupSuperclassIdAddDesc.json");

		Dataset ds = new CSVDataset("src/test/resources/lookupBatteryIdAddDescData.csv", false);
		
		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		loadData(dl, "doLookupBatteryIdAddDesc LOOKUP", cacheFlag);
		
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/lookupBatteryIdAddDesc.json");
		TestGraph.queryAndCheckResults(sgJson, this, "/lookupBatteryIdAddDescResults.csv");
		
	}
	  
	@Test
	public void test_LookupBatteryIdAddDescShort() throws Exception {
		doLookupBatteryIdAddDescShort("loadTestDuraBatteryShortData", "lookupBatteryIdAddDescShortData", "lookupBatteryIdAddDesc", "lookupBatteryIdAddDescShortResults", false);
		doLookupBatteryIdAddDescShort("loadTestDuraBatteryShortData", "lookupBatteryIdAddDescShortData", "lookupBatteryIdAddDesc", "lookupBatteryIdAddDescShortResults", true);
	}
	
	@Test
	public void test_LookupBatteryIdAddDescBound() throws Exception {
		doLookupBatteryIdAddDescShort("loadTestDuraBatteryData", "lookupBatteryIdAddDescData", "lookupBatteryIdAddDesc", "lookupBatteryIdAddDescResults", true);
		doLookupBatteryIdAddDescShort("loadTestDuraBatteryData", "lookupBatteryIdAddDescData", "lookupBatteryIdAddDescBound", "lookupBatteryIdAddDescResultsBound", true);
	}

	public void doLookupBatteryIdAddDescShort(String battCsvBasename, String descCsvBasename, String addDescJsonBasename, String resultsCsvBasename, boolean cacheFlag) throws Exception {
		// setup
		TestGraph.clearGraph();
				
		// ==== pre set some data =====
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson0 = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");
		Dataset ds0 = new CSVDataset("src/test/resources/" + battCsvBasename + ".csv", false);

		DataLoader dl0 = new DataLoader(sgJson0, ds0, TestGraph.getUsername(), TestGraph.getPassword());
		loadData(dl0, battCsvBasename + " preload batt", cacheFlag);
				
		LocalLogger.logToStdErr("------ done import 1 -------");		
		// Try URI lookup
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/" + addDescJsonBasename + ".json");

		Dataset ds = new CSVDataset("src/test/resources/" + descCsvBasename + ".csv", false);
		
		// import the actual test: lookup URI and add description
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		loadData(dl, addDescJsonBasename + " ingest desc", cacheFlag);

		TestGraph.queryAndCheckResults(sgJson, this, "/" + resultsCsvBasename + ".csv");
		
	}
	
	@Test
	public void test_LookupBatteryIdAddDescUTF8() throws Exception {
		doLookupBatteryIdAddDescUTF8(false);
		doLookupBatteryIdAddDescUTF8(true);
	}

	public void doLookupBatteryIdAddDescUTF8(boolean cacheFlag) throws Exception {
		// setup
		TestGraph.clearGraph();
				
		// ==== pre set some data =====
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson0 = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");
		Dataset ds0 = new CSVDataset("src/test/resources/loadTestDuraBatteryUTF8Data.csv", false);

		DataLoader dl0 = new DataLoader(sgJson0, ds0, TestGraph.getUsername(), TestGraph.getPassword());
		loadData(dl0, "testLookupBatteryIdAddDescUTF8 preload", cacheFlag);
				
		LocalLogger.logToStdErr("------ done import 1 -------");	
		
		// Try URI lookup
		// lookupBatteryIdAddDescAndRetThem:  does not return the Battery URI.  (See "what-were-we-thinking" above)
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/lookupBatteryIdAddDescAndRetThem.json");
		Dataset ds = new CSVDataset("src/test/resources/lookupBatteryIdAddDescUTF8Data.csv", false);
		
		// import the actual test: lookup URI and add description
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		loadData(dl, "testLookupBatteryIdAddDescUTF8", cacheFlag);

		TestGraph.queryAndCheckResults(sgJson, this, "/lookupBatteryIdAddDescUTF8Results.csv");
		
	}
	
	@Test
	public void testLookupBatteryId_lookupFails() throws Exception {
		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
	
		// Try URI lookup
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/lookupBatteryIdAddDesc.json");
		Dataset ds = new CSVDataset("src/test/resources/lookupBatteryIdAddDescShortData.csv", false);
		
		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);


		Table err = dl.getLoadingErrorReport();
		assertEquals(20, err.getNumRows());		
		assertTrue(err.getRowAsCSVString(5).toLowerCase().contains("uri lookup"));
	}
	
	@Test
	public void testDurabatteryLookupByEnum() throws Exception {
		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
	
		// Try URI lookup
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromResource(this, "loadTestDuraBatteryLookupByEnum.json");
		Dataset ds = new CSVDataset(
							"cellId,Color\n" 
							+ "red_cell1,red\n" 
							+ "red_cell2,http://kdl.ge.com/durabattery#red", 
							true);
		
		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		assertEquals(2, dl.getTotalRecordsProcessed());

		Table results = TestGraph.execTableSelect(sgJson);
		// hoping to add both cellId's to 1 cell because it is looked up by some version of "red"
		assertEquals("Multiple instances created with URILookup using enum red vs http://url#red", results.getColumnUniqueValues("Cell").length, 1);
	}
	
	@Test
	public void testDurabatteryLookupByUri() throws Exception {
		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
	
		// Try URI lookup
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromResource(this, "loadTestDuraBatteryLookupByUri.json");
		Dataset ds = new CSVDataset(
							"batteryId,Cell\n"
							+ "created1,myCell\n"
							+ "created2,http://semtk.research.ge.com/generated#myCell", 
							true);
		
		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		assertEquals(2, dl.getTotalRecordsProcessed());

		Table results = TestGraph.execTableSelect(sgJson);
		// hoping to add both cellId's to 1 cell because it is looked up by some version of "myCell"
		assertEquals("Multiple instances created with URILookup using uri myCell vs http://semtk.research.ge.com/generated#myCell ", results.getColumnUniqueValues("DuraBattery").length, 1);
	}
	
	@Test
	public void testLoadLookupFailTwoFound() throws Exception {
		
		// Lookup fails because two matching URI's are found
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryShortData.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import durabattery twice.  
		// Puts two copies of each cell (GUID URI)  on each battery (mapped URI)
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
		// second load
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		// the real test
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/lookupCellDuraBattery.json");
		// real test's load
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		
		if (err.getNumRows() != 20) {
			LocalLogger.logToStdErr("Expecting 20 error rows, found: \n" + err.toCSVString());
			fail();
		}
		assertTrue(err.toCSVString().toLowerCase().contains("uri lookup"));
		
	}
	
	@Test
	public void testLoadLookXNodes() throws Exception {
		// Look for a battery with three cells A1, B1, C1
		// Add a fourth new cell, D100
		// Tests lookup across SNode connections since it looks up a battery by three cell's ids.
		// It also tests that the lookup nodegroup is pruned properly
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import durabattery first4.  
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestDuraBatteryFirst4Results.csv");

		// the real test
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBatteryLookXNodes.json");
		ds = new CSVDataset("src/test/resources/loadTestDuraBatteryLookXNodesData.csv", false);
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestDuraBatteryLookXNodesResults.csv");
	}
	
	@Test
	public void testMissingURILookups() throws Exception {
		//  Combinations of missing URI Lookups
		//      1) error:  1 of 2 missing
		//      2) success:  both missing and item can be pruned
		//      3) error:   both missing but can't be pruned do to data property being ingested on looked up item
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import durabattery first4.  
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestDuraBatteryFirst4Results.csv");

		// Lookup up Battery by two fields battery id and connected cell's id.
		// The battery id is missing
		// Fails:  to URI lookups with one non-empty and one empty
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBatteryLookupXEmptyLookup.json");
		ds = new CSVDataset("src/test/resources/loadTestDuraBatteryLookupXEmptyLookupFail.csv", false);
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		assertEquals("Expected one error due to missing lookup", 1, err.getNumRows());
		
		// Lookup up Battery by two fields battery id and connected cell's id.
		// Succeeds:  Both URI lookups are missing, so 
		//            battery is pruned and cell is inserted with no connection
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBatteryLookupXEmptyLookup.json");
		ds = new CSVDataset("src/test/resources/loadTestDuraBatteryLookupXEmptyLookupsOK.csv", false);
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBatteryFindOrphanCells.json");
		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestDuraBatteryLookupXEmptyLookupsOKResults.csv");
		
		// Lookup up Battery by two fields battery id and connected cell's id.
		// Fails:  Both URI lookups are missing, but 
		//            battery can not be pruned because battery_desc is not empty
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBatteryLookupXEmptyLookup.json");
		ds = new CSVDataset("src/test/resources/loadTestDuraBatteryLookupXEmptyLookupsFail2.csv", false);
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		assertEquals("Expected one error when can't prune empty battery lookup due to battery desc", 1, err.getNumRows());
	}
	
	@Test
	public void testLoadLookXNodesTwoConn() throws Exception {
		assumeTrue("Test skipped due to recurring virtuoso error on v-test", TestGraph.getSei().getServerType() != "virtuoso");
		doLoadLookXNodesTwoConn(true);
		doLoadLookXNodesTwoConn(false);
	}
	public void doLoadLookXNodesTwoConn(boolean cacheFlag) throws Exception {
		// Repeat testLoadLookXNodes() with an extra data connection graph
		// ingest into a different graph
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);

		// setup as normal
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import durabattery first4 as normal
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		loadData(dl, "doLoadLookXNodesTwoConn preload", cacheFlag);
		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestDuraBatteryFirst4Results.csv");

		// the real test.   Note that "both" means standard model + data
		SparqlEndpointInterface seiBoth = TestGraph.getSei();
		SparqlEndpointInterface seiData0 = TestGraph.getSei(TestGraph.generateGraphName("data0"));
		seiData0.clearGraph();
		
		SparqlConnection connBothPlusData0 = TestGraph.getSparqlConn();
		connBothPlusData0.clearDataInterfaces();
		connBothPlusData0.addDataInterface(seiData0);
		connBothPlusData0.addDataInterface(seiBoth);
		
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBatteryLookXNodes.json");
		sgJson.setSparqlConn(connBothPlusData0);
		ds = new CSVDataset("src/test/resources/loadTestDuraBatteryLookXNodesData.csv", false);
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		loadData(dl, "doLoadLookXNodesTwoConn", cacheFlag);
		

		// query both graphs should get full results
		// query contains both + data0
		// New data should come back
		String query = TestGraph.getNodeGroupWithOInfo(sgJson).generateSparqlSelect();
		IntegrationTestUtility.querySeiAndCheckResults(query, seiBoth, this, "/loadTestDuraBatteryLookXNodesResults.csv");
		
		// generate query with only "both" sei in the FROM clause should only return original load
		// query only contains both (not data0)
		// new data shouldn't show up
		// original first4 should still return just those 4
		sgJson.setSparqlConn(TestGraph.getSparqlConn());
		query = TestGraph.getNodeGroupWithOInfo(sgJson).generateSparqlSelect();
		IntegrationTestUtility.querySeiAndCheckResults(query, seiBoth, this, "/loadTestDuraBatteryFirst4Results.csv");
	}
	
	@Test
	public void testLoadConnectNodes() throws Exception {
		// Connect cell will id "D" to cell4 of batteries with ids: "nocells" and "three"
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import durabattery first4.  
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		// the real test
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/lookupBatteryConnectNodes.json");
		ds = new CSVDataset("src/test/resources/lookupBatteryConnectNodesData.csv", false);
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		TestGraph.queryAndCheckResults(sgJson, this, "/lookupBatteryConnectNodesResults.csv");
	}
	
	@Test
	public void testLookupByEnum() throws Exception {
		// lookup battery with cell1 and cell2 both blue, and change the assembly Date to 3/23/66 8:00
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import durabattery first4.  
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
		// the real test 
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestLookupByEnum.json");
		ds = new CSVDataset("src/test/resources/loadTestLookupByEnumData.csv", false);
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestLookupByEnumResults.csv");
	}
	
	@Test
	public void testLookupByEnumBlanks() throws Exception {
		// try looking up on two enums but one is blank.  throw error
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import durabattery first4.  
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail(err.toCSVString());
		}
		
		// the real test : look up battery by two colors and add assembly date.  But one color is blank.
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestLookupByEnum.json");
		ds = new CSVDataset("src/test/resources/loadTestLookupByEnumBlanksData.csv", false);
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		// make sure there's an error on URI lookup
		if (err.getNumRows() != 1) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail("Missing URILookup error using blank enum");
		}

		assertTrue(err.toCSVString().contains("ookup"));
	}
	
	@Test
	/**
	 * Test URI Lookup when there are two copies of the identical lookup.
	 * In this case: ingesting chain links that are connected
	 * Both the "to" and "from" column are links that are looked up by name, create_if_missing
	 * Ingestion should only create each link once.
	 * Original implementation ingested each twice.
	 * 
	 * @throws Exception
	 */
	public void testLookupDuplicate() throws Exception {
		Dataset ds = new CSVDataset("src/test/resources/chain_duplicate_lookup.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/chain.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/chain_duplicate_lookup.json");

		// load chain where links named A, B, and C appear in both "from" and "to" columns
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
		// test to see that only three links, A,B,C were created.  
		Table res = TestGraph.execSelectFromResource(this, "chain_duplicate_lookup_results.json");
		assertEquals("Import with identical lookups on two columns returned wrong number of results", 3, res.getNumRows());
	}
	
	@Test
	public void testLookupPruneBlanks() throws Exception {
		
		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		
		// the real test : look up battery by two colors and add assembly date.  But one color is blank.
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestLookupPruneBlanks.json");
		CSVDataset ds = new CSVDataset("src/test/resources/loadTestLookupPruneBlanks.csv", false);
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		
		// no errors
		if (err.getNumRows() != 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
		// load it again, just for grins.  Nothing should happen.
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		
		// no errors
		if (err.getNumRows() != 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
		// test results
		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestLookupPruneBlanksResults.csv");


	}
	@Test
	public void testLookupCreate() throws Exception {
		//  lookup Fails:    create 4 new batteries with assemglyDate, batteryDesc, batteryId
		//  lookup Succeeds: add assemblyDate to battery with batteryId="onlycolor"
		//  leave alone:     batteryId=three should remain un-changed
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import durabattery first4.  
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
		// the real test  
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestLookupCreate.json");
		ds = new CSVDataset("src/test/resources/loadTestLookupCreateData.csv", false);
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		if (err.getNumRows() != 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestLookupCreateResults.csv");
	}
	
	@Test
	public void testLookupCreateNOPROPS() throws Exception {
		//  Just like testLookupCreate
		//  Except ingestion nodegroup has no return values, no sparqlIDs on the properties
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import durabattery first4.  
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			fail(err.toCSVString());
		}
		
		// the real test  
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestLookupCreate_NOPROPS.json");
		ds = new CSVDataset("src/test/resources/loadTestLookupCreateData.csv", false);
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		if (err.getNumRows() != 0) {
			fail(err.toCSVString());
		}

		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestLookupCreate.json");
		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestLookupCreateResults.csv");
	}
	
	@Test
	public void testLookupSuperclass() throws Exception {
		//  Load lookup by superclass
		//  and make sure the superclass type is not ingested as a second type for the existing object
		//  pet_ingest_pet_nicknames.json also tests the "return type" feature of the select query
		
		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/Pet.owl");
		SparqlGraphJson sgJson1 = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/pet_ingest_cat_info.json");
		SparqlGraphJson sgJson2 = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/pet_ingest_pet_nicknames.json");
		Dataset ds1 = new CSVDataset("src/test/resources/pet_cat_info.csv", false);
		Dataset ds2 = new CSVDataset("src/test/resources/pet_nicknames.csv", false);

		// extra debugging
		LocalLogger.logToStdErr("Extra: sgJson1 sparql conn ------------");
		LocalLogger.logToStdErr(sgJson1.getSparqlConn().toString());
		
		LocalLogger.logToStdErr("Extra: TestGraph sparql conn ------------");
		LocalLogger.logToStdErr(TestGraph.getSparqlConn().toString());
		
		LocalLogger.logToStdErr("Extra: sgJson1 classes  ------------");
		OntologyInfo oInfo = new OntologyInfo(sgJson1.getSparqlConn());
		LocalLogger.logToStdErr(oInfo.getClassNames().toString());
		
		LocalLogger.logToStdErr("Extra: TestGraph classes  ------------");
		OntologyInfo oInfo1 = new OntologyInfo(TestGraph.getSparqlConn());
		LocalLogger.logToStdErr(oInfo1.getClassNames().toString());
		// end extra debugging
		
		// import cat info using class "Cat".  Unexplained test failure on next line on vesuvius-test
		DataLoader dl = new DataLoader(sgJson1, ds1, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
		// now add nicknames using URI lookup on superclass "Pet"
		
		dl = new DataLoader(sgJson2, ds2, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		if (err.getNumRows() != 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		// test that cat's don't have double type Pet
		// sgJson2 does double-duty ingesting and this select query
		TestGraph.queryAndCheckResults(sgJson2, this, "/pet_nickname_results.csv");
	}
	
	
	@Test
	public void testLookupCreatePartial() throws Exception {
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import durabattery first4.  
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
		// the real test  
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestLookupCreatePartial.json");
		ds = new CSVDataset("src/test/resources/loadTestLookupCreatePartialData.csv", false);
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		if (err.getNumRows() != 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
		// check that results match expected in csv
		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestLookupCreatePartialResults.csv");
		
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBatteryCellIdQuery.json");
		String query = TestGraph.getNodeGroupWithOInfo(sgJson).generateSparql(AutoGeneratedQueryTypes.COUNT, false, -1, null);
		Table tab = TestGraph.runQuery(query);
		assertEquals(7, tab.getCellAsInt(0, 0));
	}
	
	
	@Test
	public void testCaseTransform() throws Exception {
		// Paul
		// Test string with \r and \n

		String uri = "testCaseTransform";
		String guy = "fred";
		String stuff = "STUFF";
		// set up the data
		String contents = "cell,size in,lot,material,guy,treatment\n" + String.format("%s,,,%s,%s,", uri, stuff, guy);

		Dataset ds = new CSVDataset(contents, true);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/testTransforms.owl");

		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/testTransforms.json");

		// calculate expected uri after applying transform. Capitalize all the
		// "E"s in the column value but not the text "Cell_"
		String prefix = sgJson.getImportSpecHandler().getUriPrefix();
		uri = prefix + "Cell_" + uri.replaceAll("e", "E");


		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			fail(err.toCSVString());
		}

		// look for triples

		NodeGroup nodegroup = TestGraph.getNodeGroupWithOInfo(sgJson);
		returnProp(nodegroup, "Cell", "cellId");
		returnProp(nodegroup, "ScreenPrinting", "pasteVendor");
		returnProp(nodegroup, "ScreenPrinting", "pasteMaterial");
		constrainUri(nodegroup, "Cell", uri);

		String query = nodegroup.generateSparql(AutoGeneratedQueryTypes.SELECT_DISTINCT, false, null, null, false);

		Table tab = TestGraph.runQuery(query);
		if (tab.getNumRows() < 1) {
			throw new Exception("No triples were found for uri: " + uri);
		}

		// check first pasteVendor
		String answer;
		guy = guy.toUpperCase();
		stuff = stuff.toLowerCase();
		answer = tab.getRow(0).get(tab.getColumnIndex("pasteVendor"));
		if (!answer.equals(guy)) {
			fail(String.format("Inserted wrong string: %s expecting %s ", answer, guy));
		}
		answer = tab.getRow(0).get(tab.getColumnIndex("pasteMaterial"));
		if (!answer.equals(stuff)) {
			fail(String.format("Inserted wrong string: %s expecting %s ", answer, stuff));
		}
	}	
	
	
	@Test
	public void testGraphLoadBattery() throws Exception {
		SparqlGraphJson sgJson = TestGraph.initGraphWithData(this.getClass(), "sampleBattery");
		CSVDataset csvDataset = new CSVDataset("src/test/resources/sampleBattery.csv", false);
		DataLoader dl = new DataLoader(sgJson, csvDataset, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		assertEquals(dl.getTotalRecordsProcessed(), 4);
		TestGraph.queryAndCheckResults(sgJson, this, "/sampleBatteryResults.csv");
	}
	

	@Test
	public void testGraphLoadBadEnum() throws Exception {
		String csvPath = "src/test/resources/sampleBatteryBadColor.csv";
		String jsonPath = "src/test/resources/sampleBattery.json";
		String owlResource = "/sampleBattery.owl";

		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile(jsonPath);
		CSVDataset csvDataset = new CSVDataset(csvPath, false);
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, owlResource);

		DataLoader dl = new DataLoader(sgJson, csvDataset, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		String report = dl.getLoadingErrorReportBrief();

		// make sure there is a complaint about the bad color
		assertTrue(report.contains("whiteish-yellow"));
		assertTrue(dl.getTotalRecordsProcessed() == 0);
	}
	
	@Test
	public void testLookupCreateWithMapping() throws Exception {
		//  lookup Fails:    create 4 new batteries with assemglyDate, batteryDesc, batteryId
		//  lookup Succeeds: add assemblyDate to battery with batteryId="onlycolor" retaining original URI
		//  leave alone:     three others should remain un-changed
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

		// import durabattery first4.  
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
		// the real test  
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestLookupCreateWMap.json");
		ds = new CSVDataset("src/test/resources/loadTestLookupCreateData.csv", false);
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		if (err.getNumRows() != 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}

		TestGraph.queryAndCheckResults(sgJson, this, "/loadTestLookupCreateWMapResults.csv");
	}
	
	@Test
	public void testLookupCreateWithMappingFail() throws Exception {
		//  Try lookup by id that doesn't exist.  CreateIfMissing with a mapping.
		//  But the mapping uses description, and two rows have same id but diff mapping
		//  So it should fail on conflicting URI's for same lookup.
		Dataset ds = new CSVDataset("src/test/resources/loadTestDuraBatteryFirst4Data.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/loadTestDuraBattery.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestDuraBattery.json");

	  
		DataLoader dl;
		Table err;
		
		// the real test  
		sgJson = TestGraph.getSparqlGraphJsonFromFile("src/test/resources/loadTestLookupCreateWMapFail.json");
		ds = new CSVDataset("src/test/resources/loadTestLookupCreateWMapFailData.csv", false);
		dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		assertEquals("missing error", 1, err.getNumRows());
		if (err.getNumRows() != 1 || !err.getCell(0, 4).contains("Can't create a URI with two different values")) {
			assertTrue("wrong error message:" + err.toCSVString(), false);
		}
		
	}
	
	@Test
	public void test_TypesAndConstraintsViaBook() throws Exception {
		doTypesAndConstraintsViaBook(false);
		doTypesAndConstraintsViaBook(true);
	}
	
	@Test
	public void testSubProperties() throws Exception {
		// Test case has subProperties
		String csvPathCat = "src/test/resources/animalSubPropsCats.csv";
		String csvPathDog = "src/test/resources/animalSubPropsDogs.csv";
		String csvFileAncestorRes = "animalSubPropsAncestorResults.csv";
		String jsonFileCats = "animalSubPropsCats.json";
		String jsonFileDogs = "animalSubPropsDogs.json";
		String jsonFileAncestors = "animalSubPropsAncestorSelect.json";
		String owlResource = "/AnimalSubProps.owl";
		
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, owlResource);

		// load cats
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromResource(this, jsonFileCats);
		CSVDataset csvDataset = new CSVDataset(csvPathCat, false);
		DataLoader dl = new DataLoader(sgJson, csvDataset, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() != 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
		// select cats
		Table res = TestGraph.execSelectFromResource(this, jsonFileCats);
		assertEquals("Wrong number of cats", 6, res.getNumRows());
		// (note: blank is one of the values that comes back)
		assertEquals("Wrong number of demons", 2, res.getColumnUniqueValues("demonName").length);
		assertEquals("Wrong number of kittens", 4, res.getColumnUniqueValues("kittenName").length);
		
		
		// load dogs
		sgJson = TestGraph.getSparqlGraphJsonFromResource(this, jsonFileDogs);
		csvDataset = new CSVDataset(csvPathDog, false);
		dl = new DataLoader(sgJson, csvDataset, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		if (err.getNumRows() != 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
		// select dogs
		res = TestGraph.execSelectFromResource(this, jsonFileDogs);
		assertEquals("Wrong number of dogs", 1,  res.getColumnUniqueValues("dogName").length);
		assertEquals("Wrong number of puppies", 1,  res.getColumnUniqueValues("puppyName").length);
		assertEquals("Wrong number of children", 2,  res.getColumnUniqueValues("childName").length);
		
		// select ancestors:   all of dogs' and cat's children and puppies via Animal->hasChild
		// this uses superProperty + in the query
		sgJson = TestGraph.getSparqlGraphJsonFromResource(this, jsonFileAncestors);
		TestGraph.queryAndCheckResults(sgJson, this, csvFileAncestorRes);
		

	}
	
	@Test
	public void testUriLookupByUri() throws Exception {
		// Test case sets a URI if it doesn't exist
		// and also uses that URI to look up another.
		// There are tricky combination of adding the baseURI for the lookup, etc.
		String csv1Path = "src/test/resources/Person_test.csv";
		String csv2Path = "src/test/resources/Person_test2.csv";
		String csvFileRes = "PersonRes.csv";
		String jsonFile = "Person.json";
		String owlResource = "/Person.owl";
		
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, owlResource);

		// load 1
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromResource(this, jsonFile);
		CSVDataset csvDataset = new CSVDataset(csv1Path, false);
		DataLoader dl = new DataLoader(sgJson, csvDataset, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() != 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		
		
		// load 2
		sgJson = TestGraph.getSparqlGraphJsonFromResource(this, jsonFile);
		csvDataset = new CSVDataset(csv2Path, false);
		dl = new DataLoader(sgJson, csvDataset, TestGraph.getUsername(), TestGraph.getPassword());
		dl.importData(true);
		err = dl.getLoadingErrorReport();
		if (err.getNumRows() != 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
		

		sgJson = TestGraph.getSparqlGraphJsonFromResource(this, jsonFile);
		TestGraph.queryAndCheckResults(sgJson, this, csvFileRes);
		

	}
	
	public void doTypesAndConstraintsViaBook(boolean cacheFlag) throws Exception {  
		// Test important parts of RDF1.1 literal typing
		// with semtk load and semtk query
		Dataset ds = new CSVDataset("src/test/resources/book.csv", false);

		// setup
		TestGraph.clearGraph();
		TestGraph.uploadOwlResource(this, "/book.owl");
		SparqlGraphJson sgJson = TestGraph.getSparqlGraphJsonFromResource(this, "/book.json");

		// import
		DataLoader dl = new DataLoader(sgJson, ds, TestGraph.getUsername(), TestGraph.getPassword());
		
		loadData(dl, "doTypesAndConstraintsViaBook", cacheFlag);

		TestGraph.queryAndCheckResults(sgJson, this, "/bookResults.csv");
		
		queryBook("?title", 
				SupportedOperations.NOTMATCHES, 
				new String[] {"Doesn't exist","me neither","unknown"});
		queryBook("?title", 
				SupportedOperations.MATCHES, 
				new String[] {"Typed Raw SPARQL","Untyped Raw SPARQL","Ingested"});
		queryBook("?title", 
				SupportedOperations.REGEX, 
				new String[] {"e"});
		queryBook("?publishDate", 
				SupportedOperations.MATCHES, 
				new String[] {"1963-03-03"});
		queryBook("?publishDate", 
				SupportedOperations.GREATERTHAN, 
				new String[] {"1960-01-01"});
		queryBook("?publishDateTime", 
				SupportedOperations.MATCHES, 
				new String[] {"1961-01-01T01:00:00","1962-02-02T02:00:00","1963-03-03T03:00:00"});
		queryBook("?publishDateTime", 
				SupportedOperations.GREATERTHAN, 
				new String[] {"1960-01-01T01:00:00"});
		queryBook("?pages", 
				SupportedOperations.MATCHES, 
				new String[] {"300"});
		queryBook("?pages", 
				SupportedOperations.GREATERTHAN, 
				new String[] {"10"});
		queryBook("?price", 
				SupportedOperations.MATCHES, 
				new String[] {"30.99"});
		queryBook(
				"?price", 
				SupportedOperations.GREATERTHAN, 
				new String[] {"9.99"});


	}
	
	/**
	 * Build runtime constraint and run query, expecting all three books to come back
	 * @param sparqlID
	 * @param operator
	 * @param operandList
	 * @throws Exception
	 */
	private void queryBook(String sparqlID, SupportedOperations operator, String [] operandList) throws Exception {
		SparqlGraphJson sgjson = TestGraph.getSparqlGraphJsonFromResource(this, "/book.json");
		String constraintSparql = TestGraph.addRuntimeConstraint(sgjson, sparqlID, operator, operandList);
		System.out.println("   " + constraintSparql);
		// run the query
		Table tab = TestGraph.execTableSelect(sgjson);
		assertEquals("With runtime constraint: \n" + constraintSparql + "\nQuery did not return one book: \n" + tab.toCSVString(), 1, tab.getNumRows());
	}
	
	
	// fails if we don't set SparqlID
	// fails if SparqlID doesn't start with "?"
	private void returnProp(NodeGroup nodegroup, String node, String prop) throws Exception {
		PropertyItem cellId = nodegroup.getNodeBySparqlID("?" + node).getPropertyByKeyname(prop);
		cellId.setSparqlID("?" + prop);
		cellId.setIsReturned(true);
	}

	private void constrainPropRegex(NodeGroup nodegroup, String node, String prop, String regex) throws Exception{
		PropertyItem propItem = nodegroup.getNodeBySparqlID("?" + node).getPropertyByKeyname(prop);
		ValueConstraint constraint = new ValueConstraint(ValueConstraint.buildRegexConstraint(propItem.getSparqlID(), regex, propItem.getValueTypes()));
		propItem.setValueConstraint(constraint);
	}
	
	private void constrainUri(NodeGroup nodegroup, String nodeUri, String constraintUri) {
		Node node = nodegroup.getNodeBySparqlID("?" + nodeUri);
		ValueConstraint v = new ValueConstraint(String.format("VALUES ?Cell { <%s> } ", constraintUri));
		node.setValueConstraint(v);
	}

	
	private void loadData(DataLoader dl, String logName, boolean cacheFlag) throws Exception {
		if (!cacheFlag)
			dl.doNotCache();

		long start = IntegrationTestUtility.getStartTime();
		dl.importData(true);
		String entry = IntegrationTestUtility.logDuration(start, "TIMING " + logName + (cacheFlag ? " with cache" : " w/o  cache"));
		timingMessages.add(entry);
		
		Table err = dl.getLoadingErrorReport();
		if (err.getNumRows() > 0) {
			LocalLogger.logToStdErr(err.toCSVString());
			fail();
		}
	}
}
