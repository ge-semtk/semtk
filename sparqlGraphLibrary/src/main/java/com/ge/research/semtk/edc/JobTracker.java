/**
 ** Copyright 2016 General Electric Company
 **
 **
 ** Licensed under the Apache License, Version 2.0 (the "License");
 ** you may not use this file except in compliance with the License.
 ** You may obtain a copy of the License at
 ** 
 **     http://www.apache.org/licenses/LICENSE-2.0
 ** 
 ** Unless required by applicable law or agreed to in writing, software
 ** distributed under the License is distributed on an "AS IS" BASIS,
 ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ** See the License for the specific language governing permissions and
 ** limitations under the License.
 */

/**
 * Security note:  JobTracker checks job ownership and job admin before taking action.
 *                 All queries against triplestore are done as super-user
 */

package com.ge.research.semtk.edc;

import java.io.File;
import java.io.InputStream;
import java.net.URL;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashSet;
import java.util.UUID;

import org.json.simple.JSONObject;

import com.ge.research.semtk.auth.AuthorizationException;
import com.ge.research.semtk.auth.AuthorizationManager;
import com.ge.research.semtk.auth.ThreadAuthenticator;
import com.ge.research.semtk.belmont.AutoGeneratedQueryTypes;
import com.ge.research.semtk.belmont.NodeGroup;
import com.ge.research.semtk.belmont.PropertyItem;
import com.ge.research.semtk.belmont.ValueConstraint;
import com.ge.research.semtk.edc.resultsStorage.TableResultsStorage;
import com.ge.research.semtk.load.utility.SparqlGraphJson;
import com.ge.research.semtk.ontologyTools.OntologyInfo;
import com.ge.research.semtk.properties.SemtkEndpointProperties;
import com.ge.research.semtk.resultSet.Table;
import com.ge.research.semtk.resultSet.TableResultSet;
import com.ge.research.semtk.sparqlX.SparqlConnection;
import com.ge.research.semtk.sparqlX.SparqlEndpointInterface;
import com.ge.research.semtk.sparqlX.SparqlResultTypes;
import com.ge.research.semtk.sparqlX.SparqlToXUtils;
import com.ge.research.semtk.utility.LocalLogger;
import com.ge.research.semtk.utility.Utility;


/**
 *   JobTracker instantiates a connection to the tripleStore
 *   and uses it to fulfill requests for info about a jobId.
 *
 */
public class JobTracker {
	static boolean firstConstruct = true;
	SparqlEndpointInterface sei = null;
	
	public static String STATUS_SUCCESS = "Success";
	public static String STATUS_IN_PROGRESS = "InProgress";
	public static String STATUS_FAILURE = "Failure";
	
	// Can't figure out how to test this feature, so it is OFF.
	// if set to 20 it would cause "simple" job tracker queries to 
	// throw a better error if the triplestore is locked up
	// instead of causing the top-level REST call to time out.
	// value < 1 is a no-op.
	private final static int HTTP_TIMEOUT = -1;
	
	private static HashSet<String> checkedOwl = new HashSet<String>();

	public JobTracker (SparqlEndpointInterface jobSei) throws Exception {
		// make this thread safe
		this.sei = jobSei.copy();
		
		if (JobTracker.firstConstruct) {
			try {
				AuthorizationManager.setSemtkSuper();
				JobTracker.uploadOwlModelIfNeeded(this);
			} finally {
				AuthorizationManager.clearSemtkSuper();
			}
			JobTracker.firstConstruct = false;
		}
	}
	
	/**
	 * clear an upload the OWL model, with a retry 
	 * @param tracker
	 * @param retrySec
	 * @throws Exception
	 */
	public static void uploadOwlModel(JobTracker tracker, int retrySec) throws Exception {
		long timeout = System.currentTimeMillis() + (retrySec * 1000);
		
		while (true) {
			try {
				JobTracker.uploadOwlModel(tracker);
				return;
			} catch (Exception e) {
				if (System.currentTimeMillis() > timeout) {
					throw new Exception("Error uploading jobs owl model", e);
				}
			}
		}
	}
	
	/**
	 * Clear prefix and upload OWL
	 * @param tracker
	 * @throws Exception
	 */
	public static void uploadOwlModel(JobTracker tracker) throws Exception {
		String key = tracker.sei.getServerAndPort() + tracker.sei.getGraph();
		checkedOwl.add(key);
		SparqlEndpointInterface sei = tracker.createSuperuserEndpoint();
		InputStream owlStream = JobTracker.class.getResourceAsStream("/semantics/OwlModels/serviceJob.owl");
		sei.clearPrefix("http://research.ge.com/semtk/services/job");
		sei.uploadOwl(owlStream.readAllBytes());
		owlStream.close();
	}
	
	/**
	 * If needed, upload serviceJob.owl to given tracker's triplestore server/graph
	 * @param tracker
	 * @throws Exception
	 */
	private static void uploadOwlModelIfNeeded(JobTracker tracker) throws Exception {
		String key = tracker.sei.getServerAndPort() + tracker.sei.getGraph();
		
		if (! checkedOwl.contains(key)) {
			checkedOwl.add(key);
			SparqlEndpointInterface sei = tracker.createSuperuserEndpoint();
			InputStream owlStream = JobTracker.class.getResourceAsStream("/semantics/OwlModels/serviceJob.owl");
			OntologyInfo.uploadOwlModelIfNeeded(sei, owlStream);
			owlStream.close();
		}
		
	}
	
	/**
	 * Wait for completion, updating a parent process' percent complete
	 * @param jobId
	 * @param parentJobId
	 * @param parentStatus - status for parent
	 * @param pollingMsec - max wait sec between poll
	 * @param startPercent - parent start percent
	 * @param endPercent - parent end percent
	 * @throws AuthorizationException
	 * @throws Exception
	 */
	public void waitTilCompleteUpdatingParent(String jobId, String parentJobId, String defaultParentStatus, int pollingMsec, int startPercent, int endPercent) throws AuthorizationException, Exception {
		int percentComplete = 0;
		Object [] percentAndStatus;
		
		
		do {
			if (percentComplete == 0) {
				// fist time through, pass current values to parent
				percentAndStatus = this.getJobPercentCompleteAndStatusMsg(jobId);
			} else {
				// after first time, wait polling Msec
				percentAndStatus = this.waitForPercentOrMsecWithStatusMsg(jobId, 100, pollingMsec);
			}
			percentComplete = (int) percentAndStatus[0];
			int parentPercent = startPercent + (endPercent - startPercent) * percentComplete / 100;
			String status = (String) percentAndStatus[1];
			this.setJobPercentComplete(parentJobId, parentPercent, status.length() > 0 ? status : defaultParentStatus);
		} while (percentComplete < 100);
	}
	
	/**
	 * Create a jobs endpoint with one free superuser query
	 * @return
	 * @throws Exception
	 */
	private SparqlEndpointInterface createSuperuserEndpoint() throws Exception {
		
		AuthorizationManager.nextQuerySemtkSuper();
	    
		return this.sei;
		
	}
	
	/**
	 * 
	 * @param endpoint - contains results with "userName" column
	 * @param jobId
	 * @throws Exception
	 * @throws AuthorizationException
	 */
	private void throwExceptionIfNotOwner(Table results, String jobId) throws Exception, AuthorizationException {
		String owner = results.getCellAsString(0, "userName");
		AuthorizationManager.throwExceptionIfNotJobOwner(owner, "job " + jobId);
	}
	
	private void throwExceptionIfNotOwner(SparqlEndpointInterface endpoint, String jobId) throws Exception, AuthorizationException {
		String owner = endpoint.getStringResultsColumn("userName")[0];
		AuthorizationManager.throwExceptionIfNotJobOwner(owner, "job " + jobId);
	}
	
	/**
	 * Build the override connection for queries of job info
	 * @return
	 * @throws Exception
	 */
	private SparqlConnection createOverrideConnection() throws Exception {
		
		SparqlConnection ret = new SparqlConnection();
		ret.addDataInterface(this.sei);
		ret.addModelInterface(this.sei);
		return ret;
		
	}
	
	public static String generateJobId() {
		return UUID.randomUUID().toString();
	}
	
	private String getJobUri(String jobId) {
		return "http://research.ge.com/semtk/services/data/Job_" + SparqlToXUtils.safeSparqlString(jobId);
	}
	private String getFileUri(String fileId) {
		return "http://research.ge.com/semtk/services/data/File_" + SparqlToXUtils.safeSparqlString(fileId);
	}

	/**
	 * Return percent complete as a string, or throw exception
	 * @param jobId
	 * @return
	 * @throws Exception if jobId doesn't exist or job has no percentComplete
	 */
	public int getJobPercentComplete(String jobId) throws AuthorizationException, Exception {	 
		return (int) (this.getJobPercentCompleteAndStatusMsg(jobId)[0]);
	}
	
	/**
	 * Return { (Integer)percent_complete, "status or empty string" }
	 * @param jobId
	 * @return
	 * @throws Exception if jobId doesn't exist or job has no percentComplete
	 */
	public Object[] getJobPercentCompleteAndStatusMsg(String jobId) throws AuthorizationException, Exception {	    
		   
	    String query = String.format("  \n" +
	        "prefix job:<http://research.ge.com/semtk/services/job#>  \n" +
	    	"prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#>  \n" +
	    	"	  \n" +
	    	"	select distinct ?Job ?percentComplete ?statusMsg ?userName \n" +            // PEC: added ?Job for debugging double percentComplete problem 9/13/2017
	    	"   from <" + this.sei.getGraph() + "> where { " +
	    	"	   ?Job a job:Job.  \n" +
	    	"	   ?Job job:id '%s' .  \n" +
	    	"	   ?Job job:percentComplete ?percentComplete .  \n" +
	    	"	   optional { ?Job job:statusMessage ?statusMsg } .  \n" +
	    	"	   ?Job job:userName ?userName .  \n" +
	    	"	}",
	    	SparqlToXUtils.safeSparqlString(jobId));

	    SparqlEndpointInterface endpoint = this.createSuperuserEndpoint().addHttpTimeout(HTTP_TIMEOUT);
	    TableResultSet res = (TableResultSet) endpoint.executeQueryAndBuildResultSet(query, SparqlResultTypes.TABLE);
	    res.throwExceptionIfUnsuccessful();
	    Table tab = res.getTable();
	     
	    String trList[] = tab.getColumn("percentComplete");
	    this.checkEndpointUserNames(jobId, tab);
	       
	    if (trList.length > 1) {
	    	LocalLogger.logToStdErr("getJobPercentComplete found multiple percentComplete entries:\n%s" + endpoint.getResponse());
	    	throw new Exception(String.format("Job %s has %d percentComplete entries.  Expecting 1.", jobId, trList.length));
	    } else if (trList.length == 0) {
	    	if (! this.jobExists(jobId) ) {
	    		throw new Exception(String.format("Can't find Job %s", jobId));
	    	} else {
	    		throw new Exception(String.format("Can't find percent complete for Job %s",  jobId));
	    	}
	    } else {
	    	int percent = Integer.parseInt(trList[0]);
	    	
	    	if (percent < 0 || percent > 100) {
	    		throw new Exception(String.format("Trouble parsing percent complete of job %s into an int 0-100.  Value = '%s'", jobId, trList[0]));
	    	}
	    	
	    	this.throwExceptionIfNotOwner(endpoint, jobId);
		    return (new Object[] { Integer.valueOf(percent), tab.getCell(0, "statusMsg")}) ;
	    }
	}
	
	public void incrementPercentComplete(String jobId, int increment, int max) throws AuthorizationException, Exception {
		int currentPercent = this.getJobPercentComplete(jobId);
		int newPercentComplete = currentPercent + increment;
		if (newPercentComplete < max && newPercentComplete < 100) {
			this.setJobPercentComplete(jobId, newPercentComplete);
		}
	}
	
	/**
	 * Set percentComplete for a job, 
	 *   creating the job if it doesn't exist.
	 * @param jobId
	 * @param percentComplete 0-99
	 * @throws Exception
	 */
	
	public void setJobPercentComplete(String jobId, int percentComplete) throws AuthorizationException, Exception {	    
		setJobPercentComplete(jobId, percentComplete, "");
	}
	
	public void setJobPercentComplete(String jobId, int percentComplete, String message) throws AuthorizationException, Exception {	    
	   
	    if (! this.jobExists(jobId)) {
	    	this.createJob(jobId);
	    }
	    
	    if (percentComplete < 0) { 
	    	throw new Exception (String.format("Can't set job %s percent complete to negative percent complete value: %d", jobId, percentComplete));
	    }
	    if (percentComplete > 99) { 
	    	throw new Exception (String.format("Can't set job %s percent complete to 100%% or above.  Set success or failure instead.", jobId));
	    }

	    String query = String.format("  \n" +
	        "prefix job:<http://research.ge.com/semtk/services/job#> \n" +
	        "prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#> \n" +
	        " \n" +
	        "WITH <" + this.sei.getGraph() + "> " +
	        "DELETE { " +

	        "   ?Job job:percentComplete ?percentComplete .\n" +
	        "   ?Job job:status ?status ." +
	        "   ?Job job:statusMessage ?statusMessage ." +
	        "} \n" +
	        "INSERT { " +
	        "   ?Job job:percentComplete %d . \n" +
	        "   ?Job job:status job:InProgress . \n" +
	        "   job:InProgress a job:Status . \n " +
	        "   ?Job job:statusMessage '%s' . \n" +
	        "} \n" +
	        "WHERE {\n" +
	        "   ?Job job:id '%s' . \n" +
	        "   optional {?Job job:percentComplete ?percentComplete .} \n" +
	        "   optional {?Job job:status ?status .} \n" +
	        "   optional {?Job job:statusMessage ?statusMessage .}" +
	        "}",
	    	percentComplete, SparqlToXUtils.safeSparqlString(message), SparqlToXUtils.safeSparqlString(jobId));
	 	// LocalLogger.logToStdErr(query);
	    try {
		    this.createSuperuserEndpoint().addHttpTimeout(HTTP_TIMEOUT).executeQuery(query, SparqlResultTypes.CONFIRM);
	    } catch (Exception e) {
	    	throw new Exception(e.toString());
	    }
	}
	
	/**
	 * Set job to a status other than Success,
	 *    creating job if it doesn't exist
	 * @param jobId
	 * @param statusMessage
	 */
	public void setJobFailure(String jobId, String statusMessage) throws AuthorizationException, Exception {
		
		if (! this.jobExists(jobId)) {
	    	this.createJob(jobId);
	    }
	  
	    String query = String.format("  \n" +
	        "prefix job:<http://research.ge.com/semtk/services/job#> \n" +
	        "prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#> \n" +
	        " \n" +
	        "WITH <" + this.sei.getGraph() + "> " +
	        "DELETE { " +
			"   ?Job job:percentComplete ?percentComplete . \n" +
			"   ?Job job:statusMessage ?statusMessage . \n" +
	        "   ?Job job:status ?status." +
	        "} \n" +
	        "INSERT { " +
			"   ?Job job:percentComplete 100 .  \n" +
	        "   ?Job job:statusMessage '%s' . \n" +
	        "   ?Job job:status job:Failure . \n" +
	        "   job:Failure a job:Status . \n " +
	        "} \n" +
	        "WHERE { \n" +
	        "   ?Job job:id '%s' . \n" +
			"   optional {?Job job:percentComplete ?percentComplete .} \n" +
	        "   optional {?Job job:statusMessage ?statusMessage .} \n" +
	        "   optional {?Job job:status ?status .} \n" +
	        "}",
	        
	        SparqlToXUtils.safeSparqlString(statusMessage==null?"":statusMessage), SparqlToXUtils.safeSparqlString(jobId));
	 	// LocalLogger.logToStdErr(query);
	    try {
	    	this.createSuperuserEndpoint().addHttpTimeout(HTTP_TIMEOUT).executeQuery(query, SparqlResultTypes.CONFIRM);
	    } catch (Exception e) {
	    	throw new Exception(e.toString());
	    }
	}
	
	public boolean jobSucceeded(String jobId) throws AuthorizationException, Exception {
		return this.getJobStatus(jobId).equals(STATUS_SUCCESS);
	}
	
	/**
	 * Get job status local fragment as a string
	 * @param jobId
	 * @return InProgress, Success, Failure
	 * @throws Exception if jobId can't be found or has not status
	 */
	public String getJobStatus(String jobId) throws AuthorizationException, Exception {
		String query = String.format("  \n" +
				"prefix job:<http://research.ge.com/semtk/services/job#>  \n" +
				"prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#>  \n" +
				"	  \n" +
				"	select distinct ?status ?userName \n" +
		        "   from <" + this.sei.getGraph() + "> where { " +
				"	   ?Job a job:Job.  \n" +
				"	   ?Job job:id '%s' .  \n" +
				"	   ?Job job:status ?status .  \n" +
				"	   ?Job job:userName ?userName .  \n" +
				"	}",
				SparqlToXUtils.safeSparqlString(jobId));

		SparqlEndpointInterface endpoint = this.createSuperuserEndpoint().addHttpTimeout(HTTP_TIMEOUT);
	    TableResultSet res = (TableResultSet) endpoint.executeQueryAndBuildResultSet(query, SparqlResultTypes.TABLE);
	    res.throwExceptionIfUnsuccessful();
	    Table tab = res.getTable();
	    String trList[] = tab.getColumn("status");
	    this.checkEndpointUserNames(jobId, tab);
		
		
		if (trList.length > 1) {
			throw new Exception(String.format("Job %s has %d status entries.  Expecting 1.", jobId, trList.length));
		} else if (trList.length == 0) {
			if (! this.jobExists(jobId) ) {
	    		throw new Exception(String.format("Can't find Job %s", jobId));
	    	} else {
	    		throw new Exception(String.format("Can't find status for Job %s",  jobId));
	    	}
		} else {
			this.throwExceptionIfNotOwner(endpoint, jobId);
			
			return trList[0].split("#")[1];
		}
	}
	
	/**
	 * Get job status message
	 * @param jobId
	 * @return message string or "" if none.
	 * @throws Exception if jobId can't be found 
	 */
	public String getJobStatusMessage(String jobId) throws AuthorizationException, Exception {
		this.checkJobExistAndAuth(jobId);
		String query = String.format("  \n" +
				"prefix job:<http://research.ge.com/semtk/services/job#>  \n" +
				"prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#>  \n" +
				"	  \n" +
				"	SELECT DISTINCT ?statusMessage ?userName \n" +
		        "   from <" + this.sei.getGraph() + "> where { " +
		        "	   ?Job a job:Job.  \n" +
				"	   ?Job job:id '%s' .  \n" +
				"	   ?Job job:statusMessage ?statusMessage .  \n" +
				"	   ?Job job:userName ?userName .  \n" +
		    	"	}",
				SparqlToXUtils.safeSparqlString(jobId));

		SparqlEndpointInterface endpoint = this.createSuperuserEndpoint().addHttpTimeout(HTTP_TIMEOUT);
	    
	    TableResultSet res = (TableResultSet) endpoint.executeQueryAndBuildResultSet(query, SparqlResultTypes.TABLE);
	    res.throwExceptionIfUnsuccessful();
	    Table tab = res.getTable();

	    String trList[] = tab.getColumn("statusMessage");
		this.checkEndpointUserNames(jobId, tab);

		if (trList.length > 1) {
			throw new Exception(String.format("Job %s has %d statusMessage entries.  Expecting 1.", jobId, trList.length));
		} else if (trList.length == 0) {
			if (! this.jobExists(jobId) ) {
	    		throw new Exception(String.format("Can't find Job %s", jobId));
	    	} else {
	    		// job is found but message is empty: return ""
	    		return "";
	    	}
		} else {
			this.throwExceptionIfNotOwner(endpoint, jobId);
		    
			return trList[0];
		}
	}
	
	/**
	 * Get job status message
	 * @param jobId
	 * @return message string
	 * @throws Exception if jobId can't be found 
	 */
	public String[] getJobStatusAndMessage(String jobId) throws AuthorizationException, Exception {
		this.checkJobExistAndAuth(jobId);
		String query = String.format("  \n" +
				"prefix job:<http://research.ge.com/semtk/services/job#>  \n" +
				"prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#>  \n" +
				"	  \n" +
				"	SELECT DISTINCT ?status ?statusMessage ?userName \n" +
		        "   from <" + this.sei.getGraph() + "> where { " +
		        "	   ?Job a job:Job.  \n" +
				"	   ?Job job:id '%s' .  \n" +
				"	   ?Job job:userName ?userName .  \n" +
				"	   ?Job job:status ?status .  \n" +
				"	   optional { ?Job job:statusMessage ?statusMessage . } \n" +
		    	"	}",
				SparqlToXUtils.safeSparqlString(jobId));

		SparqlEndpointInterface endpoint = this.createSuperuserEndpoint().addHttpTimeout(HTTP_TIMEOUT);
	    
	    TableResultSet res = (TableResultSet) endpoint.executeQueryAndBuildResultSet(query, SparqlResultTypes.TABLE);
	    res.throwExceptionIfUnsuccessful();
	    Table tab = res.getTable();

	    int rowCount = tab.getNumRows();
		this.checkEndpointUserNames(jobId, tab);

		if (rowCount > 1) {
			throw new Exception(String.format("Job %s has %d status and message entries.  Expecting 1.", jobId, rowCount));
		} else if (rowCount == 0) {
			if (! this.jobExists(jobId) ) {
	    		throw new Exception(String.format("Can't find Job %s", jobId));
	    	} else {
	    		throw new Exception(String.format("Can't find status and message for Job %s",  jobId));
	    	}
		} else {
			this.throwExceptionIfNotOwner(endpoint, jobId);
		    
			return new String [] { tab.getCell(0, "status").split("#")[1], tab.getCell(0, "statusMessage") } ;
		}
	}


	/**
	 * Set job percent complete to 100, 
	 *   creating it if it doesn't exist.
	 * @param jobId
	 * @throws Exception
	 */
	public void setJobSuccess(String jobId) throws AuthorizationException, Exception {
		setJobSuccess(jobId, "");
	}
		
	public void setJobSuccess(String jobId, String statusMessage) throws AuthorizationException, Exception {
		
		if (! this.jobExists(jobId)) {
	    	this.createJob(jobId);
	    }
	    
		String query = String.format("  \n" +
				"prefix job:<http://research.ge.com/semtk/services/job#> \n" +
				"prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#> \n" +
				" \n" +
		        "WITH <" + this.sei.getGraph() + "> " +
		        "DELETE { " +
				"   ?Job job:percentComplete ?percentComplete . \n" +
				"   ?Job job:statusMessage ?statusMessage . \n" +
				"   ?Job job:status ?status." +
				"} \n" +
		        "INSERT { " +
				"   ?Job job:percentComplete 100 .  \n" +
				"   ?Job job:statusMessage '%s' . \n" +
				"   ?Job job:status job:Success. \n" +
				"   job:Success a job:Status . \n" +
				"} \n" +
		        "WHERE { \n" +
				"   ?Job job:id '%s' . \n" +
				"   optional {?Job job:percentComplete ?percentComplete .} \n" +
				"   optional {?Job job:statusMessage ?statusMessage.} \n" +
				"   optional {?Job job:status ?status.} \n" +
				"}",

				SparqlToXUtils.safeSparqlString(statusMessage), SparqlToXUtils.safeSparqlString(jobId));
		// LocalLogger.logToStdErr(query);
		try {
			this.createSuperuserEndpoint()
				.addHttpTimeout(HTTP_TIMEOUT)
				.executeQuery(query, SparqlResultTypes.CONFIRM);
		} catch (Exception e) {
			throw new Exception(e.toString());
		}
	}

	
	/**
	 * Set the results URL for a job,
	 *    creating it if it doesn't exist.
	 * @param jobId
	 * @param fullResultsURL
	 * @throws Exception
	 */
	public void setJobResultsURL(String jobId, URL fullResultsURL) throws AuthorizationException, Exception {
		
		if (! this.jobExists(jobId)) {
	    	this.createJob(jobId);
	    }
		
		URL sampleResultsURL = null;	// temporary measure to disable sample while not changing SPARQL query.  Matching functionality of removed utility method. 
		String uriFullURL = "URL_" + UUID.randomUUID().toString();
		String uriSampleURL = "URL_" + UUID.randomUUID().toString();

		String query = String.format("  \n" +
		        "prefix job:<http://research.ge.com/semtk/services/job#> \n" +
		        "prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#> \n" +
		        " \n" +
		        "WITH <" + this.sei.getGraph() + "> " +
		        "DELETE { " +
		        "   ?Job job:fullResultsURL ?fullURI. \n" +
		        "   ?fullURI a job:URL . \n" +
		        "   ?fullURI job:full ?fullURL .  \n" +
		        "   ?Job job:sampleResultsURL ?sampleURI. \n" +
		        "   ?sampleURI job:full ?sampleURL . \n" +
		        "   ?sampleURI a job:URL . \n" +
		        "} \n" +
		        "INSERT { " +
		        "   ?Job job:fullResultsURL <%s>. \n" +
		        "   <%s> a job:URL . \n " + 
		        "   <%s> job:full '%s' .  \n" +
		        "   ?Job job:sampleResultsURL <%s>. \n" +
		        "   <%s> a job:URL . \n " +
		        "   <%s> job:full '%s' . \n" +
		        "} \n" +
		        "WHERE {\n" +
		        "   ?Job job:id '%s' . \n" +
		        "   optional {?Job job:fullResultsURL ?fullURI. \n" +
		        "             ?fullURI job:full ?fullURL . } \n" +
		        "   optional {?Job job:sampleResultsURL ?sampleURI. \n" +
		        "             ?sampleURI job:full ?sampleURL . } \n" +
		        "}",
		        uriFullURL, 
		        uriFullURL, 
		        uriFullURL, 
		        SparqlToXUtils.safeSparqlString(fullResultsURL.toString()), 
		        uriSampleURL, 
		        uriSampleURL, 
		        uriSampleURL,
		        ((sampleResultsURL != null) ? SparqlToXUtils.safeSparqlString(sampleResultsURL.toString()) : ""), 
		        SparqlToXUtils.safeSparqlString(jobId));
		// LocalLogger.logToStdErr(query);
		try {
			this.createSuperuserEndpoint()
				.addHttpTimeout(HTTP_TIMEOUT)
				.executeQuery(query, SparqlResultTypes.CONFIRM);
		} catch (Exception e) {
			throw new Exception(e.toString());
		}
	}

	/**
	 * Get a jobId's full results URL
	 * @param jobId
	 * @return URL which could be null if none exist
	 * @throws Exception if jobId can't be found full URL is malformed or multiples exist, etc.
	 */
	public URL getOptionalFullResultsURL(String jobId) throws AuthorizationException, Exception {	 
		
		// TODO: this should be a nodegroup and use generateSparql()
		String query = String.format("  \n" +
	        "prefix job:<http://research.ge.com/semtk/services/job#>  \n" +
	    	"prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#>  \n" +
	    	"	  \n" +
	    	"	SELECT DISTINCT ?fullUrl ?userName \n" +
	        "   FROM <" + this.sei.getGraph() + "> where { " +
	    	"	   ?Job a job:Job.  \n" +
	    	"	   ?Job job:id '%s' .  \n" +
	    	"	   ?Job job:fullResultsURL ?URL.  \n" +
			"	   ?Job job:userName ?userName .  \n" +
			"      ?URL job:full ?fullUrl . \n" +
	    	"	}",
	    	SparqlToXUtils.safeSparqlString(jobId));

		SparqlEndpointInterface endpoint = this.createSuperuserEndpoint();
	    TableResultSet res = (TableResultSet) endpoint
				.addHttpTimeout(HTTP_TIMEOUT)
				.executeQueryAndBuildResultSet(query, SparqlResultTypes.TABLE);
	    res.throwExceptionIfUnsuccessful();
	    Table tab = res.getTable();
	    
	    String trList[] = tab.getColumn("fullUrl");
	    this.checkEndpointUserNames(jobId, tab);

	    if (trList.length > 1) {
	    	throw new Exception(String.format("Job %s has %d full results URL entries.  Expecting 1.", jobId, trList.length));
	    } else if (trList.length == 0) {
	    	return null;
	    } else if (trList[0].equals("")) {
    		throw new Exception(String.format("Empty full results URL for Job %s", jobId));
	    } else {
	    	this.throwExceptionIfNotOwner(endpoint, jobId);
		    
	    	return new URL(trList[0]);
	    }
	}
	
	/**
	 * Get full results URL
	 * @param jobId
	 * @return
	 * @throws Exception unless exactly one properly formed full URL is found
	 */
	public URL getFullResultsURL(String jobId) throws AuthorizationException, Exception {	 
		URL ret = this.getOptionalFullResultsURL(jobId);
		if (ret == null) {
			throw new Exception(String.format("Can't find full URL for Job %s",  jobId));
		}
		return ret;
	}
	
	/**
	 * Get a jobId's full results URL
	 * @param jobId
	 * @return URL which could be null
	 * @throws Exception if jobID can't be found or it doesn't have exactly one sample URL
	 */
	public URL getSampleResultsURL(String jobId) throws AuthorizationException, Exception {	 
		// TODO: this should be a nodegroup and use generateSparql()
		String query = String.format("  \n" +
	        "prefix job:<http://research.ge.com/semtk/services/job#>  \n" +
	    	"prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#>  \n" +
	    	"	  \n" +
	    	"	SELECT DISTINCT ?sampleUrl ?userName \n" +
	        "   FROM <" + this.sei.getGraph() + "> where { " +
	    	"	   ?Job job:id '%s' .  \n" +
	    	"	   ?Job job:sampleResultsURL ?URL.  \n" +
			"	   ?Job job:userName ?userName .  \n" +
	    	"      ?URL job:full ?sampleUrl . \n" +
	    	"	}",
	    	SparqlToXUtils.safeSparqlString(jobId));

		SparqlEndpointInterface endpoint = this.createSuperuserEndpoint();
	    TableResultSet res = (TableResultSet) endpoint
				.addHttpTimeout(HTTP_TIMEOUT)
				.executeQueryAndBuildResultSet(query, SparqlResultTypes.TABLE);
	    res.throwExceptionIfUnsuccessful();
	    Table tab = res.getTable();
		
	    String trList[] = tab.getColumn("sampleUrl");
	    this.checkEndpointUserNames(jobId, tab);

	    if (trList.length > 1) {
	    	throw new Exception(String.format("Job %s has %d full restults URL entries.  Expecting 1.", jobId, trList.length));
	    } else if (trList.length == 0) {
	    	if (! this.jobExists(jobId) ) {
	    		throw new Exception(String.format("Can't find Job %s", jobId));
	    	} else {
		    	throw new Exception(String.format("Can't find sample URL for Job %s",  jobId));
	    	}
	    } else if (trList[0].equals("")) {
	    	return null;
	    } else {
	    	this.throwExceptionIfNotOwner(endpoint, jobId);
		    
	    	return new URL(trList[0]);
	    }
	}
	
	/**
	 * Create a Job with given jobId.  
	 * @param jobId
	 * @throws Exception
	 */
	public void createJob(String jobId) throws Exception {	
		// Note: createJob can be called by two different threads colliding on the same JobId without bad consequences.
	    
		// Testing only
		String userName = ThreadAuthenticator.getThreadUserName();
		LocalLogger.logToStdOut("creating job " + jobId + " principal.user_name=" + userName);
		
		// get the current date and time...
		DateFormat xsdFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
		Calendar cal = Calendar.getInstance();

		Date initialDate = cal.getTime();
		
		String jobUri = this.getJobUri(jobId);
		
		// delete in case job already exists (save the job and id, they are solid)
	    String query = String.format("  \n" +
	        "prefix job:<http://research.ge.com/semtk/services/job#> \n" +
	        "prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#> \n" +
	        " \n" +
	        "WITH <" + this.sei.getGraph() + "> " +
	        "DELETE { " +
            "?job ?pred ?obj . \n " +
	        "} \n" +
	        "INSERT { " +
	        "?job a job:Job. \n" + 
	        "?job job:id '%s' . \n" +
            "?job job:creationTime '%s'^^XMLSchema:dateTime . \n" +
	        "?job job:percentComplete 0 . \n" +
	        "?job job:userName '%s' . \n" +
	        "?job job:status job:InProgress. \n" +
			"job:InProgress a job:Status. \n" +
	        "}\n" +
	        "WHERE {\n" +
	        "BIND (<%s> AS ?job)\n" +
	        "}\n",
	        
	        SparqlToXUtils.safeSparqlString(jobId), 
	        xsdFormat.format(initialDate), 
	        userName,
	        jobUri);
	    // LocalLogger.logToStdErr(query);
	    try {
	    	this.createSuperuserEndpoint()
				.addHttpTimeout(HTTP_TIMEOUT)
				.executeQuery(query, SparqlResultTypes.CONFIRM);
	    } catch (Exception e) {
	    	throw new Exception(e.toString());
	    }
	}

	public void setJobName(String jobId, String name) throws AuthorizationException, Exception {
		
		if (! this.jobExists(jobId)) {
	    	this.createJob(jobId);
	    }
		String jobUri = this.getJobUri(jobId);
		String safeName = SparqlToXUtils.safeSparqlString(name);
		
		String query = String.format("  \n" +
		        "prefix job:<http://research.ge.com/semtk/services/job#> \n" +
		        "prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#> \n" +
		        " \n" +
		        "WITH <" + this.sei.getGraph() + "> " +
		        "DELETE { " +
	            "?job job:name ?x. \n" +
		        "} \n" +
		        "INSERT { " +
		        "?job job:name '%s'. \n" +
		        "}\n" +
		        "WHERE {\n" +
		        "BIND (<%s> AS ?job)\n" +
		        "}\n",
		        safeName,
		        jobUri
		       );
	    try {
	    	this.createSuperuserEndpoint().executeQuery(query, SparqlResultTypes.CONFIRM);
	    } catch (Exception e) {
	    	throw new Exception(e.toString());
	    }

	}
	public void addBinaryFile(String jobId, String fileId, String filename, String path) throws AuthorizationException, Exception {
		
		if (! this.jobExists(jobId)) {
	    	this.createJob(jobId);
	    }
		
		String jobUri = this.getJobUri(jobId);
		String fileUri = this.getFileUri(fileId);
		
		String query = String.format("  \n" +
				"prefix job:<http://research.ge.com/semtk/services/job#> \n" +
				"prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#> \n" +
				" \n" +
		        "WITH <" + this.sei.getGraph() + "> " +
		        "INSERT { " +
				"?file a job:BinaryFile. \n" + 
				"?job job:file ?file. \n" +
				"?file job:fileID   '%s' . \n" +
				"?file job:filename '%s' . \n" +
				"?file job:path     '%s' . \n" +
				"}\n" +
		        "WHERE {\n" +
		        "BIND (<%s> AS ?file)\n" +
		        "BIND (<%s> AS ?job)\n" +
		        "}\n",
				
				fileId,
				filename,
				path,
				fileUri,
				jobUri
				);
	    try {
	    	this.createSuperuserEndpoint().executeQuery(query, SparqlResultTypes.CONFIRM);
	    } catch (Exception e) {
	    	throw new Exception(e.toString());
	    }
	}
	
	/**
	 * Get info about a file
	 * @param jobId
	 * @return
	 * @throws Exception
	 * @throws AuthorizationException, Exception
	 */
	public JobFileInfo getBinaryFile(String fileId) throws AuthorizationException, Exception {
		
		// get nodegroup
		JSONObject jObj = Utility.getResourceAsJson(this, "/nodegroups/job_get_file.json");
		SparqlGraphJson sgj = new SparqlGraphJson(jObj);
		sgj.setSparqlConn(this.createOverrideConnection());
		NodeGroup ng = sgj.getNodeGroup();
		
		// set constraint
		PropertyItem fileIdProp = ng.getPropertyItemBySparqlID("fileID");
		ArrayList<String> valList = new ArrayList<String>();
		valList.add(fileId);
		fileIdProp.setValueConstraint(new ValueConstraint(ValueConstraint.buildFilterInConstraint(fileIdProp, valList)));
		
		// run query
		String query = ng.generateSparql(AutoGeneratedQueryTypes.SELECT_DISTINCT, false, -1, null);
		TableResultSet res = null;
		try {
			SparqlEndpointInterface endpoint = this.createSuperuserEndpoint();
		    res = (TableResultSet) endpoint.executeQueryAndBuildResultSet(query, SparqlResultTypes.TABLE);
	    } catch (Exception e) {
	    	throw new Exception(e.toString());
	    }
		Table table = res.getTable();
		if (table.getNumRows() < 1) { throw new Exception("Could not find file: " + fileId); }
		if (table.getNumRows() > 1) { throw new Exception("Found more than one file with fileId: " + fileId); }
		
		// set results
		JobFileInfo ret = new JobFileInfo();
		ret.setFileId(fileId);
		ret.setFileName(table.getCell(0, "filename"));
		ret.setUserName(table.getCell(0, "userName"));
		ret.setPath(table.getCell(0, "path"));
		
		AuthorizationManager.throwExceptionIfNotJobOwner(ret.getUserName(), "fileId=" + fileId);
		return ret;
	}
	
	/**
	 * Get table of jobs info for current thread userName
	 * Note that status is modified to match STATUS_ values
	 * @return table of "creationTime" "id" "name" "percentComplete" "userName" "status"  "statusMessage"
	 * @throws Exception
	 */
	public Table getJobsInfo() throws Exception {
		// get nodegroup
		JSONObject jObj = Utility.getResourceAsJson(this, "/nodegroups/jobs_get_info.json");
		SparqlGraphJson sgj = new SparqlGraphJson(jObj);
		sgj.setSparqlConn(this.createOverrideConnection());
		NodeGroup ng = sgj.getNodeGroup();
		
		// set constraint unless administrator
		if (!AuthorizationManager.isSemtkSuper()) {
			PropertyItem prop = ng.getPropertyItemBySparqlID("userName");
			ArrayList<String> valList = new ArrayList<String>();
			valList.add(ThreadAuthenticator.getThreadUserName());
			prop.setValueConstraint(new ValueConstraint(ValueConstraint.buildFilterInConstraint(prop, valList)));
			prop.setOptMinus(PropertyItem.OPT_MINUS_NONE);

		}		
		
		// run query
		String query = ng.generateSparql(AutoGeneratedQueryTypes.SELECT_DISTINCT, false, -1, null);
		TableResultSet res = null;
		try {
			SparqlEndpointInterface endpoint = this.createSuperuserEndpoint();
		    res = (TableResultSet) endpoint.executeQueryAndBuildResultSet(query, SparqlResultTypes.TABLE);
	    } catch (Exception e) {
	    	throw new Exception(e.toString());
	    }
		Table table = res.getTable();
		
		int statusCol = table.getColumnIndex("status");
		for (int i=0; i < table.getNumRows(); i++) {
			table.setCell(i, statusCol, table.getCell(i, statusCol).split("#")[1]);
		}
		
		return table;
	}
	
	/**
	 * Delete jobs and their file paths before a given date
	 * @param boundaryDate
	 * @throws Exception
	 */
	
	// PEC TODO
	// next two functions should have a TableResultsStorage so they can do a fullDelete on the jobId
	// DeleteThread could then clean up any leftover files ??
	public void deleteJobsAndFiles(Date boundaryDate) throws AuthorizationException, Exception {
		this.deleteJobsAndFiles(boundaryDate, null);
	}
	
	/**
	 * Delete job from triplestore, delete binary files and their parents if empty, delete table storage if provided
	 * @param boundaryDate
	 * @param trstore - may be null
	 * @throws Exception
	 */
	public void deleteJobsAndFiles(Date boundaryDate, TableResultsStorage trstore) throws AuthorizationException, Exception {
		
		// --- delete binary files --- 
		SparqlGraphJson sgjGetPaths = new SparqlGraphJson(Utility.getResourceAsJson(this, "/nodegroups/job_get_file_info.json"));
		sgjGetPaths.setSparqlConn(this.createOverrideConnection());
		NodeGroup ngGetPaths = sgjGetPaths.getNodeGroup();
		
		// add creationTime constraint
		PropertyItem creationTime = ngGetPaths.getPropertyItemBySparqlID("creationTime");
		String creationTimeConstraint = ValueConstraint.buildFilterConstraint(creationTime, "<", boundaryDate);	
		creationTime.setValueConstraint(new ValueConstraint(creationTimeConstraint));
		
		// delete binary files: query paths, then delete
		String query = ngGetPaths.generateSparql(AutoGeneratedQueryTypes.SELECT_DISTINCT, false, -1, null);
		SparqlEndpointInterface endpoint = this.createSuperuserEndpoint();
	    Table pathTable = endpoint.executeQueryToTable(query);
		String paths[] = pathTable.getColumn("path");
		for (String p : paths) {
			this.deleteBinaryFile(p);
		}
		
		// --- delete result file storage --- 
		ArrayList<URL> resultsUrls = this.getResultsUrls(boundaryDate);
		for (URL u : resultsUrls) {
			if (trstore != null) {
				trstore.fullDelete(u);
			} else {
				LocalLogger.logToStdErr("Leaving file for later cleanup: " + u.toString());
			}
		}

		// --- delete from triplestore --- 
		SparqlGraphJson sgjJobDeletion = new SparqlGraphJson(Utility.getResourceAsJson(this, "/nodegroups/job_deletion.json"));
		sgjJobDeletion.setSparqlConn(this.createOverrideConnection());
		NodeGroup ngJobDel = sgjJobDeletion.getNodeGroup();
		
		// add creationTime constraint
		creationTime = ngJobDel.getPropertyItemBySparqlID("creationTime");
		creationTimeConstraint = ValueConstraint.buildFilterConstraint(creationTime, "<", boundaryDate);	
		creationTime.setValueConstraint(new ValueConstraint(creationTimeConstraint));
		
		// run
		query = ngJobDel.generateSparqlDelete();
		
		// we've already checked that user is JobAdmin.  So user can delete jobs from triplestore.
		endpoint = this.createSuperuserEndpoint();
		endpoint.executeQueryAndConfirm(query);
		LocalLogger.logToStdOut("Deleted jobs from triplestore: " + creationTimeConstraint);

		
	}
	
	/**
	 * Delete a binary file if it exists.  And it's parent if it becomes empty.
	 * @param filePath
	 */
	private void deleteBinaryFile(String filePath) {
		try {
			File f = new File(filePath);
		
			if (f.exists()) {
				File parent = f.getParentFile();
				f.delete();
				LocalLogger.logToStdOut("Deleted binary file: " + filePath);

				
				if (parent.isDirectory() && parent.list().length == 0) {
					parent.delete();
					LocalLogger.logToStdOut("Deleted empty parent dir: " + parent.getAbsolutePath());

				}
			}
		} catch (Exception e) {
			e.printStackTrace(System.err);
		}
	}
	
	/**
	 * Delete jobs and their file paths before a given date
	 * @param boundaryDate
	 * @throws Exception
	 */
	public void deleteJob(String jobId) throws AuthorizationException, Exception {
		this.deleteJob(jobId, null);
	}

	public void deleteJob(String jobId, TableResultsStorage trstore) throws AuthorizationException, Exception {
		
		// delete binary files
		ArrayList<JobFileInfo> fileInfoList = this.getJobBinaryFiles(jobId);
		
		for (JobFileInfo info : fileInfoList) {
			this.deleteBinaryFile(info.getPath());
		}
		 
		// delete results table storage
		URL[] u = this.getOptionalResultsUrls(jobId);
		if (u[0] != null) {
			if (trstore != null) {
				trstore.fullDelete(u[0]);
			} else {
				LocalLogger.logToStdErr("Leaving file for cleanup later: " + u[0].toString());
			}
		}
		if (u[1] != null) {
			if (trstore != null) {
				trstore.fullDelete(u[1]);
			} else {
				LocalLogger.logToStdErr("Leaving file for cleanup later: " + u[1].toString());
			}
		}

		this.checkJobAuthIfExists(jobId);
		
		// get job deletion nodegroup
		SparqlGraphJson sgjJobDeletion = new SparqlGraphJson(Utility.getResourceAsJson(this, "/nodegroups/job_deletion.json"));
		sgjJobDeletion.setSparqlConn(this.createOverrideConnection());
		NodeGroup ngJobDel = sgjJobDeletion.getNodeGroup();
		
		// add id constraint
		PropertyItem idItem = ngJobDel.getPropertyItemBySparqlID("id");
		ArrayList<String> valList = new ArrayList<String>();
		valList.add(SparqlToXUtils.safeSparqlString(jobId));
		String jobIdConstraint = ValueConstraint.buildFilterInConstraint(idItem, valList);	
		idItem.setValueConstraint(new ValueConstraint(jobIdConstraint));
		
		// delete from triplestore
		this.createSuperuserEndpoint().executeQueryAndConfirm(ngJobDel.generateSparqlDelete());
		LocalLogger.logToStdOut("Deleted job from triplestore: " + jobIdConstraint);
		
	}
	
	public ArrayList<JobFileInfo> getJobBinaryFiles(String jobId) throws AuthorizationException, Exception {
		ArrayList<JobFileInfo> ret = new ArrayList<JobFileInfo>();
		
		// get nodegroup
		SparqlGraphJson sgjGetPaths = new SparqlGraphJson(Utility.getResourceAsJson(this, "/nodegroups/job_get_file_info.json"));
		sgjGetPaths.setSparqlConn(this.createOverrideConnection());
		NodeGroup ngGetPaths = sgjGetPaths.getNodeGroup();
		
		// set id constraint
		PropertyItem idItem = ngGetPaths.getPropertyItemBySparqlID("id");
		ArrayList<String> valList = new ArrayList<String>();
		valList.add(SparqlToXUtils.safeSparqlString(jobId));
		String jobIdConstraint = ValueConstraint.buildFilterInConstraint(idItem, valList);	
		idItem.setValueConstraint(new ValueConstraint(jobIdConstraint));
		
		// run query
		String query = ngGetPaths.generateSparql(AutoGeneratedQueryTypes.SELECT_DISTINCT, false, -1, null);
		Table pathTable = this.createSuperuserEndpoint().executeQueryToTable(query);
		
		if (pathTable.getNumRows() > 0) 
			this.throwExceptionIfNotOwner(pathTable, jobId);
		
		// change results into JobFileInfo objects
		for (int i=0; i < pathTable.getNumRows(); i++) {
			JobFileInfo info = new JobFileInfo();
			info.setFileId(pathTable.getCell(i, "fileID"));
			info.setFileName(pathTable.getCell(i, "filename"));
			info.setPath(pathTable.getCell(i, "path"));
			info.setUserName(pathTable.getCell(i, "userName"));
			AuthorizationManager.throwExceptionIfNotJobOwner(info.getUserName(), "fileId="+info.getFileId());
			ret.add(info);
		}
		
		return ret;
	}
	
	/**
	 * Get all sample and full URLs before date
	 * @param boundaryDate
	 * @return
	 * @throws Exception
	 */
	public ArrayList<URL> getResultsUrls(Date boundaryDate) throws AuthorizationException, Exception {

		ArrayList<URL> ret = new ArrayList<URL>();
		
		// get nodegroup
		SparqlGraphJson sgjson = new SparqlGraphJson(Utility.getResourceAsJson(this, "/nodegroups/job_get_results_urls.json"));
		sgjson.setSparqlConn(this.createOverrideConnection());
		NodeGroup ng = sgjson.getNodeGroup();
		
		// add creationTime constraint
		PropertyItem creationTime = ng.getPropertyItemBySparqlID("creationTime");
		String laterThanConstraint = ValueConstraint.buildFilterConstraint(creationTime, "<", boundaryDate);	
		creationTime.setValueConstraint(new ValueConstraint(laterThanConstraint));
		
		// run query
		String query = ng.generateSparql(AutoGeneratedQueryTypes.SELECT_DISTINCT, false, -1, null);
		SparqlEndpointInterface supersei = this.createSuperuserEndpoint();
		Table urlTable = supersei.executeQueryToTable(query);
		
		int fullUrlPos = urlTable.getColumnIndex("fullResultsURL");
		int sampleUrlPos = urlTable.getColumnIndex("sampleResultsURL");
		int userNamePos = urlTable.getColumnIndex("userName");
		int jobIdPos = urlTable.getColumnIndex("id");
		for (int i=0; i < urlTable.getNumRows(); i++) {
			if (!urlTable.getCell(i, fullUrlPos).isEmpty()) {
				try {
					ret.add(new URL(urlTable.getCell(i, "fullResultsURL")));
				} catch (Exception e) {
					LocalLogger.logToStdErr("Skipping poorly formed fullResultURL: " + urlTable.getCell(i, fullUrlPos));
				}
				AuthorizationManager.throwExceptionIfNotJobOwner(urlTable.getCell(i, userNamePos), "jobId=" + urlTable.getCell(i, jobIdPos));   
			}
			if (!urlTable.getCell(i, sampleUrlPos).isEmpty()) {
				try {
					ret.add(new URL(urlTable.getCell(i, sampleUrlPos)));
				} catch (Exception e) {
					LocalLogger.logToStdErr("Skipping poorly formed sampleResultURL: " + urlTable.getCell(i, fullUrlPos));
				}
				AuthorizationManager.throwExceptionIfNotJobOwner(urlTable.getCell(i, userNamePos), "jobId=" + urlTable.getCell(i, jobIdPos));   
			}
		}
		
		return ret;
	}
	
	/**
	 * Get [sampleURL, fullURL].  Either or both can be null.
	 * @param jobId
	 * @return
	 * @throws Exception - multiple rows of results, REST errors
	 */
	public URL[] getOptionalResultsUrls(String jobId) throws AuthorizationException, Exception {
		this.jobExists(jobId);
		URL ret[] = new URL[2];
		
		// get nodegroup
		SparqlGraphJson sgjson = new SparqlGraphJson(Utility.getResourceAsJson(this, "/nodegroups/job_get_results_urls.json"));
		sgjson.setSparqlConn(this.createOverrideConnection());
		NodeGroup ng = sgjson.getNodeGroup();
		
		// set id constraint
		PropertyItem idItem = ng.getPropertyItemBySparqlID("id");
		ArrayList<String> valList = new ArrayList<String>();
		valList.add(SparqlToXUtils.safeSparqlString(jobId));
		String jobIdConstraint = ValueConstraint.buildFilterInConstraint(idItem, valList);	
		idItem.setValueConstraint(new ValueConstraint(jobIdConstraint));
		
		// run query
		String query = ng.generateSparql(AutoGeneratedQueryTypes.SELECT_DISTINCT, false, -1, null);
		Table urlTable = this.createSuperuserEndpoint().executeQueryToTable(query);
		
		if (urlTable.getNumRows() == 0) {
			ret[0] = null;
			ret[1] = null;

		} else {
			String user = urlTable.getCell(0, "userName");
			AuthorizationManager.throwExceptionIfNotJobOwner(user, "jobId=" + jobId);   
			
			if (urlTable.getNumRows() > 1) {
				throw new Exception ("Job has multiple results URLs: " + jobId);

			} else {
				String sample = urlTable.getCell(0, "sampleResultsURL");
				String full = urlTable.getCell(0, "fullResultsURL");
				ret[0] = sample.isEmpty() ? null : new URL(sample);
				ret[1] = full.isEmpty() ? null : new URL(full);
			}
		}
		
		return ret;
	}
	
	private void checkJobExistAndAuth(String jobId) throws AuthorizationException, Exception {
		if (!this.jobExists(jobId)) {
			throw new Exception("Job does not exsit: " + jobId);
		}
	}
	private void checkJobAuthIfExists(String jobId) throws AuthorizationException, Exception {
		this.jobExists(jobId);
	}
	/**
	 * Make sure every row returned from previous query has an authorized userName
	 * @param jobId
	 * @throws AuthorizationException
	 * @throws Exception
	 */
	private void checkEndpointUserNames(String jobId, Table tab) throws AuthorizationException, Exception {
		// security
	    String userList[] = tab.getColumn("userName");
	    if (userList.length > 0) {
	    	for (String user : userList) {
	    		AuthorizationManager.throwExceptionIfNotJobOwner(user, "jobId=" + jobId);
	    	}
	    } else {
	    	// query returned nothing, check for AuthorizationError so non-owner doesn't see empty results
	    	this.checkJobAuthIfExists(jobId);
	    }
	   
	}
	
	/**
	 * Does jobId exist
	 * @param jobId
	 * @return
	 * @throws AuthorizationException - job exists but user is not authorized
	 * @throws Exception - any other error
	 */
	public boolean jobExists(String jobId) throws AuthorizationException, Exception {

		if(jobId == null){
			throw new Exception("Cannot check if job exists: jobId is null");
		}
		
		String query = String.format("  \n" +
				"prefix job:<http://research.ge.com/semtk/services/job#> \n" +
		        "prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#> \n" +
				"SELECT ?id ?userName \n" +
		        "from <" + this.sei.getGraph() + "> " +
				"where { \n" +
				"   ?Job a job:Job. \n" +
				"   ?Job job:id ?id. \n" +
				"      VALUES ?id { '%s' }. \n" +
				"   ?Job job:userName ?userName. \n" +
				"}",
				SparqlToXUtils.safeSparqlString(jobId));
		
		Table jobTable = this.createSuperuserEndpoint().executeQueryToTable(query);
	    int rows = jobTable.getNumRows();
		
	    if (rows == 0) {
	    	// job does not exist
	    	return false;
	    	
	    } else if (rows == 1) {
	    	// is user authorized
	    	String jobUserName = jobTable.getCell(0, "userName");
	    	AuthorizationManager.throwExceptionIfNotJobOwner(jobUserName, "job " + jobId);
	    	
	    	// yes: one job and authorized
	    	return true;
	    	
	    } else {
	    	// multiple owners is possible in collision.  Lock everyone out.
	    	String userNames = String.join(",", jobTable.getColumn("userName"));
	    	throw new Exception("Job jobId=" + jobId + " has multiple owners: " + userNames);
	    }		
	}

	/**
	 * Return when job with given jobId is at least percentComplete % complete
	 * @param jobId
	 * @param percentComplete
	 * @param maxWaitMsec
	 * @throws Exception if maxWaitMsec milliseconds pass without a return
	 */
	public void waitForPercentComplete(String jobId, int percentComplete, int maxWaitMsec) throws AuthorizationException, Exception {
		int totalMsec = 0;
		int sleepMsec = 0;
		
		// wait maximum of this.prop.jobMaxWatiMsec
		while (totalMsec < maxWaitMsec) {
			if (this.getJobPercentComplete(jobId) >= percentComplete) {
				return;
			}
			// wait 1/4 seconds longer each time until 3 seconds
			if (sleepMsec < 3000) {
				sleepMsec += 250;
			}
			Thread.sleep(sleepMsec);
			totalMsec += sleepMsec;
		}
		throw new Exception(String.format("Maximum wait time of %d Msec has passed without job %s reaching %d percent complete.", maxWaitMsec, jobId, percentComplete));
	}
	
	/**
	 * Wait for success, throwing an exception if not.
	 * @param jobId
	 * @param maxWaitSec
	 * @throws Exception
	 */
	public void waitForSuccess(String jobId, int maxWaitMsec) throws Exception {
		int percent = this.waitForPercentOrMsec(jobId, 100, maxWaitMsec);
		if (percent < 100) {
			throw new Exception(String.format("Job %s not complete within %d seconds ", jobId, maxWaitMsec));
		}
		if (!this.jobSucceeded(jobId)) {
			throw new Exception(String.format("Job %s failed: %s", jobId, this.getJobStatusMessage(jobId)));
		}
		return;
	}
	/**
	 * Return when job is at least percentComplete complete or maxWaitMse have expired
	 * @param jobId
	 * @param percentComplete
	 * @param maxWaitMsec
	 * @returns percent complete
	 * @throws Exception on error
	 */
	public int waitForPercentOrMsec(String jobId, int percentComplete, int maxWaitMsec) throws AuthorizationException, Exception {
		return (int) this.waitForPercentOrMsecWithStatusMsg(jobId, percentComplete, maxWaitMsec)[0];
	}
	
	public Object[] waitForPercentOrMsecWithStatusMsg(String jobId, int percentComplete, int maxWaitMsec) throws AuthorizationException, Exception {
		long sleepMsec = 200;
		int actualPercent = 0;
		long now = System.currentTimeMillis();
		long endTime = now + maxWaitMsec;
		String status = "";
		
		now -= 1; // make sure we run the loop at least once
		
		while (now < endTime) {
			Object percentAndStatus[] = this.getJobPercentCompleteAndStatusMsg(jobId);
			actualPercent = (int) percentAndStatus[0];
			status = (String) percentAndStatus[1];
			if (actualPercent >= percentComplete) {
				break;
			}
			
			// wait 1.3x seconds longer each time until 3 seconds
			if (sleepMsec < 3000) {
				sleepMsec = Math.round(sleepMsec * 1.3);
			}
			
			// don't wait past projected end time
			now = System.currentTimeMillis();
			sleepMsec = Math.min(sleepMsec, (endTime - now) );
			
			if (sleepMsec > 0) {
				Thread.sleep(sleepMsec);
				now = System.currentTimeMillis();
			}
		}
		return new Object [] {actualPercent, status};
	}
	
	/**
	 * If it is possible to confirm that job failed, get message.
	 * null means either job succeeded or unknown due to some other problem.
	 * Meant for use during error handling.
	 * @param jobId
	 * @return
	 */
	public String tryForFailureMessage(String jobId) {
		try {
			if (this.jobSucceeded(jobId)) {
				return null;
			} else {
				return this.getJobStatusMessage(jobId);
			}
		} catch (Exception e) {
			return null;
		}
	}
}
