package com.ge.research.semtk.api.nodeGroupExecution;

import java.util.AbstractCollection;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Set;

import com.ge.research.semtk.api.nodeGroupExecution.client.NodeGroupExecutionClient;
import com.ge.research.semtk.auth.HeaderTable;
import com.ge.research.semtk.auth.ThreadAuthenticator;
import com.ge.research.semtk.belmont.AutoGeneratedQueryTypes;
import com.ge.research.semtk.belmont.Node;
import com.ge.research.semtk.belmont.NodeDeletionTypes;
import com.ge.research.semtk.belmont.NodeGroup;
import com.ge.research.semtk.belmont.ValueConstraint;
import com.ge.research.semtk.edc.JobTracker;
import com.ge.research.semtk.edc.client.ResultsClient;
import com.ge.research.semtk.nodeGroupStore.client.NodeGroupStoreRestClient;
import com.ge.research.semtk.resultSet.Table;
import com.ge.research.semtk.sparqlToXLib.SparqlToXLibUtil;
import com.ge.research.semtk.sparqlX.SparqlConnection;
import com.ge.research.semtk.sparqlX.SparqlEndpointInterface;
import com.ge.research.semtk.sparqlX.SparqlResultTypes;
import com.ge.research.semtk.sparqlX.SparqlToXUtils;
import com.ge.research.semtk.sparqlX.dispatch.client.DispatchRestClient;
import com.ge.research.semtk.utility.LocalLogger;

/**
 * Process a table full of requests to combine entities by lookup
 * @author 200001934
 *
 */
public class StitchingThread extends Thread {
	private HeaderTable headerTable = null;
	
	private StitchingStep steps[];
	private HashSet<String> commonCols;
	private SparqlConnection conn = null;
	private NodeGroupStoreRestClient storeClient = null;
	private DispatchRestClient dispatchClient = null;
	private ResultsClient resultsClient = null;
	private SparqlEndpointInterface servicesSei = null;
	
	private JobTracker tracker = null;
	private String jobId = null;
	
	private Table stitched = null;
	private Hashtable<String, HashSet<String>> newColumnNames = null;
	/**
	 * @throws Exception 

	 */
	public StitchingThread(
			StitchingStep [] steps, HashSet<String> commonCols, SparqlConnection conn, 
			NodeGroupStoreRestClient storeClient, DispatchRestClient dispatchClient, ResultsClient resultsClient, 
			SparqlEndpointInterface servicesSei, String jobId) throws Exception {
	
		this.headerTable = ThreadAuthenticator.getThreadHeaderTable();
		this.steps = steps;
		this.commonCols = commonCols;
		this.conn = conn;
		this.storeClient = storeClient;
		this.dispatchClient = dispatchClient;
		this.resultsClient = resultsClient;
		this.servicesSei = servicesSei;
		this.tracker = new JobTracker(servicesSei);
		
		this.jobId = jobId;
		this.tracker.createJob(this.jobId);
		
	}
	
	
	public void run() {
		ThreadAuthenticator.authenticateThisThread(this.headerTable);
		
		try {
			
			
			for (int i=0; i < this.steps.length; i++) {
				StitchingStep step = this.steps[i];
				int progress = i * 100 / (this.steps.length);
				this.tracker.setJobPercentComplete(this.jobId, progress , "Running nodegroup: " + step.getNodegroupId());

				NodeGroupExecutor executor = new NodeGroupExecutor(this.storeClient, this.dispatchClient, this.resultsClient, this.servicesSei, null);
				Table tab = executor.selectToTableById(conn, step.getNodegroupId());
				this.stitch(tab, step);
			}
			
			this.finalizeStitchedTable();
			
			this.resultsClient.execStoreTableResults(this.jobId, this.stitched);
			this.tracker.setJobSuccess(jobId);

		} catch (Exception e) {
			LocalLogger.printStackTrace(e);
			try {
				// Exceptions are reported via the async job status mechanism
				this.tracker.setJobFailure(this.jobId, "Error during stitching. \n" + e.getMessage());

			} catch (Exception ee) {
				// Bail from total mess with log messages and a stranded job
				LocalLogger.logToStdErr("CombineEntitiesTableThread stranded a job due to another exception during setJobFailure()");
				LocalLogger.printStackTrace(ee);
			}
		}
	}
	
	// for junit
	public Table testStitchTable(Table tab, StitchingStep step) throws Exception {
		this.stitch(tab, step);
		this.tracker.setJobSuccess(jobId);
		return this.stitched;
	}
	
	public void testFinalizeStitchedTable() throws Exception{
		this.finalizeStitchedTable();
	}
	
	/**
	 * @param tab - table to be stitched.  WARNING: col names may be modified
	 * @param step
	 * @throws Exception
	 */
	private void stitch(Table tab, StitchingStep step) throws Exception {
		
		if (this.stitched == null) {
			// first table: copy it in
			this.stitched = tab.copy();
			
			// change all the column names and save new name in newColumnNames
			this.newColumnNames = new Hashtable<String, HashSet<String>>();
			for (String tabColName : tab.getColumnNames()) {
				if (!this.commonCols.contains(tabColName)) {
					HashSet<String> set = new HashSet<String>();
					String newName =  tabColName + '-' + step.getNodegroupId();
					set.add(newName);
					this.newColumnNames.put(tabColName, set);
					this.stitched.changeColumnName(tabColName, newName);
				}
			}
			
		} else {
			ArrayList<String> keyColumns = new ArrayList<String>();
			keyColumns.addAll(Arrays.asList(step.getKeyColumns()));
			
			// Note: here is where you could try auto-detecting key columns
			
			// appends "-ngname" to non-keys and non-commonCols
			this.uniquifyColumnNames(keyColumns, step.getNodegroupId(), tab);
			
			// add any column name in tab that isn't yet in stitched
			String tabColNames[] = tab.getColumnNames();
			String tabColTypes[] = tab.getColumnTypes();
			for (int i=0; i < tabColNames.length; i++) {
				if (this.stitched.getColumnIndex(tabColNames[i]) < 0) {
					this.stitched.appendColumn(tabColNames[i], tabColTypes[i]);
				}
			}
			
			ArrayList<ArrayList<String>> newRows = new ArrayList<ArrayList<String>>();
			
			// for each row in stitched : look for matches in new tab
			for (int stitchRow=0; stitchRow < this.stitched.getNumRows(); stitchRow++) {
				// make a mini-table of matching rows from tab
				Table tabMatch = tab.getSubsetWhereMatches(keyColumns.get(0), this.stitched.getCell(stitchRow,  keyColumns.get(0)));
				for (int i=1; i < keyColumns.size(); i++) {
					tabMatch = tabMatch.getSubsetWhereMatches(keyColumns.get(i), this.stitched.getCell(stitchRow,  keyColumns.get(i)));
				}
				
				if (tabMatch.getNumRows() > 0) {
					// sub in values from first matching row
					for (String colName : tabMatch.getColumnNames()) {
						if (this.commonCols.contains(colName)) {
							// handle commonCols
							String existVal = this.stitched.getCell(stitchRow, colName);
							String newVal = tabMatch.getCell(0, colName);
							this.stitched.setCell(stitchRow, colName, this.calculateCommonCol(existVal, newVal, colName));
							
						} else {
							// copy rest in : keycol values overwrite identical, normal col values are set
							this.stitched.setCell(stitchRow, colName, tabMatch.getCell(0, colName));
						}
					}
					
					// make new rows for rest of matching rows
					for (int tabMatchRow=1; tabMatchRow < tabMatch.getNumRows(); tabMatchRow++) {
						ArrayList<String> newStitchedRow = new ArrayList<String>();
						// copy target row in stitched
						newStitchedRow.addAll(this.stitched.getRow(stitchRow));
						// substitute in all values from matched row
						for (String colName : tabMatch.getColumnNames()) {
							if (this.commonCols.contains(colName)) {
								// handle commonCols
								String existVal = this.stitched.getCell(stitchRow, colName);
								String newVal = tabMatch.getCell(0, colName);
								this.stitched.setCell(stitchRow, colName, this.calculateCommonCol(existVal, newVal, colName));
								
							} else {
								newStitchedRow.set(this.stitched.getColumnIndex(colName), tabMatch.getCell(tabMatchRow, colName));
							}
						}
						newRows.add(newStitchedRow);
					}
				}
			}
			
			// for each  tab row  : if it wasn't stitched,  append it instead
			for (int tabRow=0; tabRow < tab.getNumRows(); tabRow++) {
				// make a mini-table of matching rows from stitched
				Table stitchMatch = this.stitched.getSubsetWhereMatches(keyColumns.get(0), tab.getCell(tabRow, keyColumns.get(0)));
				for (int i=1; i < keyColumns.size(); i++) {
					stitchMatch = stitchMatch.getSubsetWhereMatches(keyColumns.get(i), tab.getCell(tabRow,  keyColumns.get(i)));
				}
				// if tab row doesn't match anything in stitched, copy it over
				if (stitchMatch.getNumRows() == 0) {
					ArrayList<String> newStitchedRow = new ArrayList<String>();
					for (int i=0; i < this.stitched.getNumColumns(); i++) {
						newStitchedRow.add("");
					}
					// substitute in all values unmatched row in tab
					for (String colName : tab.getColumnNames()) {
						newStitchedRow.set(this.stitched.getColumnIndex(colName), tab.getCell(tabRow, colName));
					}
					newRows.add(newStitchedRow);
				}
			}
			
			// add all the new rows to stitched table
			for (ArrayList<String> newRow : newRows) {
				this.stitched.addRow(newRow);
			}
		}
	}
	
	/**
	 * Returns the proper value to set a commonCol.
	 * @param existVal - current value
	 * @param newVal - proposed new value
	 * @param colName
	 * @return
	 * @throws Exception - if existVal and newVal are both nonBlank, and aren't equal
	 */
	private String calculateCommonCol(String existVal, String newVal, String colName) throws Exception {
		if (existVal.isBlank()) {
			if (!newVal.isBlank()) {
				// exist is blank, new is not:  add it
				return newVal;
			}
			// both are blank: do nothing
		} else {
			// exist and new are non-blank:  make sure they match
			if (!newVal.isBlank() && !newVal.equals(existVal)) {
				throw new Exception("CommonCol " + colName + " values don't match: " + existVal + "," + newVal);
			}
			// exist is non-blank, new is blank: do nothing
		}
		return existVal;
	}
	/**
	 * Change unstitched and non-commonCol column names in tab to "colName-nodegroupId"
	 * As new stitching cols appear, change a column name in this.stitched back from "colName-nodegroupId" to "colName"
	 * @param keyColumns
	 * @param tab
	 * @return Hashtable<old>=new   of name changes in tab
	 * @throws Exception
	 */
	private void uniquifyColumnNames(ArrayList<String> keyColumns, String nodegroupId, Table tab) throws Exception {
		//
		// Check all the incoming column names:
		//    if it IS NOT A KEY_COL then change the name to "columnName-nodegroupId"
		//    	(it it only happens once for columnName, we'll change it back at the end)
		//    if it IS A KEY_COL then make sure it is in the stitched table already
		//
				
		for (String tabColName : tab.getColumnNames()) {
		
			if (keyColumns.contains(tabColName)) {
				// it is a keyColumn.
				if (this.stitched.getColumnIndex(tabColName) == -1) {
					// it has not been stitched yet
					HashSet<String> newNames = this.newColumnNames.get(tabColName);
					
					if (newNames == null) {
						throw new Exception("Stitching " + nodegroupId + "failed: key column has not been seen in previous tables: " + tabColName);
					} else if (newNames.size() > 1) {
						throw new Exception("Stitching " + nodegroupId + "failed: key column is unstitched in previous tables: " + tabColName);
					} else {
						// leave the tab colName alone.
						// change this.stitched column name back to it's original name 
						//		and delete it's entry in this.newColumnNames
						for (String onlyNewName : this.newColumnNames.get(tabColName)) {
							this.stitched.changeColumnName(onlyNewName, tabColName);
						}
						this.newColumnNames.remove(tabColName);
					}
				}  // else it is already fine: column is in this.stitched table with it's original name already
				
			} else if (! this.commonCols.contains(tabColName)) {
			
				// it is not a keyColumn nor commonCol
				// so change tab colName to "colName-nodeGroupId"
				String newName = tabColName + '-' + nodegroupId;
				tab.changeColumnName(tabColName, newName);
				
				// and save the old/new mapping in this.newColumnNames
				if (this.newColumnNames.containsKey(tabColName)) {
					this.newColumnNames.get(tabColName).add(newName);
				} else {
					HashSet<String> set = new HashSet<String>();
					set.add(newName);
					this.newColumnNames.put(tabColName, set);
				}
			}
		}
		return;
	}
	
	/**
	 * Stitching process as changed every unstitched column name to "colName-nodegroupId"
	 * Change any unstitched column names that only appeared in one table back to their original names
	 * @throws Exception
	 */
	private void finalizeStitchedTable() throws Exception {
		for (String origName : this.newColumnNames.keySet()) {
			HashSet<String> newNames = this.newColumnNames.get(origName);
			if (newNames.size() == 1) {
				for (String onlyNewName : this.newColumnNames.get(origName)) {
					this.stitched.changeColumnName(onlyNewName, origName);
				}
			}
		}
	}
}
